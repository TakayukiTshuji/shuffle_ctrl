<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>カード配置アプリ</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            overflow: hidden;
        }
        .grabbing {
            cursor: grabbing;
        }
        .card-container {
            perspective: 1000px;
            -webkit-touch-callout: none; /* iOS Safari */
            touch-action: manipulation;  /* Prevent default touch actions */
            transition: left 0.5s cubic-bezier(0.2, 0.8, 0.2, 1), top 0.5s cubic-bezier(0.2, 0.8, 0.2, 1);
        }
        .card-container.grabbing {
            transition: none;
        }
        .card-inner {
            position: relative;
            width: 100%;
            height: 100%;
            transition: transform 0.6s, box-shadow 0.2s, border 0.2s;
            transform-style: preserve-3d;
            border: 3px solid transparent;
            border-radius: 0.5rem;
        }
        .selected .card-inner {
            border-color: #3b82f6; /* blue-500 */
            box-shadow: 0 0 15px rgba(59, 130, 246, 0.8);
        }
        .card-container.flipped .card-inner {
            transform: rotateY(180deg);
        }
        .card-front, .card-back {
            position: absolute;
            width: 100%;
            height: 100%;
            -webkit-backface-visibility: hidden;
            backface-visibility: hidden;
            border-radius: 0.5rem;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .card-back {
            background-color: #4A90E2;
            color: white;
            transform: rotateY(180deg);
            border: 2px solid white;
        }
        dialog::backdrop {
          background: rgba(0, 0, 0, 0.5);
        }
        #canvas {
            width: 10000px; 
            height: 10000px; 
            background-size: 120px 170px; 
            background-position: -60px -85px; 
            transform-origin: 0 0; 
            will-change: transform;
        }
        .show-grid {
            background-image: 
                linear-gradient(to right, rgba(255, 255, 255, 0.1) 4px, transparent 5px),
                linear-gradient(to bottom, rgba(255, 255, 255, 0.1) 4px, transparent 5px);
        }
        #feedback-msg {
            transition: opacity 0.5s ease-in-out;
        }
        .delete-btn {
            position: absolute;
            top: -10px;
            right: -10px;
            width: 28px;
            height: 28px;
            background-color: #ef4444;
            color: white;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            line-height: 1;
            font-weight: bold;
            cursor: pointer;
            opacity: 0;
            transition: opacity 0.2s, transform 0.2s;
            border: 2px solid white;
            z-index: 10;
            transform: scale(0.8);
        }
        .card-container:hover .delete-btn {
            opacity: 1;
            transform: scale(1);
        }
        .mode-active {
            background-color: #2563eb !important; /* blue-600 */
            box-shadow: inset 0 2px 4px 0 rgba(0, 0, 0, 0.2);
        }
        #selection-box {
            position: absolute;
            border: 2px dashed #3b82f6;
            background-color: rgba(59, 130, 246, 0.2);
            pointer-events: none;
            z-index: 9999;
            display: none;
        }
        #resizer {
            width: 8px;
            background-color: #cbd5e1;
            cursor: col-resize;
            transition: background-color 0.2s;
            flex-shrink: 0;
            z-index: 50;
        }

        #resizer:hover, #resizer.resizing {
            background-color: #3b82f6;
        }
        #board {
            overflow: hidden; /* autoから変更 */
        }
        .protocol-item {
            background-color: #fff;
            border: 1px solid #e2e8f0;
            border-radius: 0.375rem;
            padding: 0.5rem;
            margin-bottom: 0.5rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-shadow: 0 1px 2px 0 rgba(0, 0, 0, 0.05);
        }
        .protocol-item:before {
            content: "▼";
            color: #94a3b8;
            font-size: 0.7rem;
            margin-right: 0.5rem;
        }
        .executing {
            border-color: #3b82f6;
            background-color: #eff6ff;
            box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.5);
        }
        #scroll-wrapper {
            position: relative;
            transform-origin: 0 0;
        }
    </style>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&family=Noto+Sans+JP:wght@400;700&display=swap" rel="stylesheet">
</head>
<body class="bg-gray-100">
    <div class="flex h-screen w-screen">
        <!-- 左側のカード配置エリア -->
        <main id="board" class="flex-grow h-full bg-gray-700 relative shadow-inner overflow-hidden">
            <div id="scroll-container" style="width: 100%; height: 100%; overflow: auto; position: relative;">
                <div id="scroll-wrapper" style="position: relative; transform-origin: 0 0;">
                    <div id="canvas" class="relative bg-green-800">
                        <div id="selection-box"></div>
                    </div>
                </div>
                <div class="absolute top-4 left-4 text-white text-lg bg-black bg-opacity-30 p-2 rounded-lg pointer-events-none" style="z-index: 100;">
                    <h1 class="font-bold text-xl">カード配置エリア</h1>
                    <p class="text-sm">・ダブルクリック/タップで裏返せます。</p>
                    <p class="text-sm">・ドラッグ/スワイプで移動できます。</p>
                    <p class="text-sm">・「グループ選択モード」で複数選択できます。</p>
                </div>
            </div>
        </main>

        <!-- リサイザー要素 -->
        <div id="resizer" title="ドラッグしてパネル幅を調整"></div>

        <!-- 右側のコントロールパネル -->
        <aside id="control-panel" class="flex-none bg-gray-200 p-4 shadow-lg flex flex-col space-y-4 overflow-y-auto" style="width: 400px; min-width: 220px; max-width: 1000px;">
            <h2 class="text-2xl font-bold text-gray-800 border-b-2 border-gray-400 pb-2">コントロールパネル</h2>
            
            <!-- ★★★ ステータスパネル (枚数・カウンター) ★★★ -->
            <div class="bg-white p-3 rounded-lg shadow space-y-2 text-sm text-gray-700">
                <div class="flex justify-between border-b pb-1">
                    <span>総カード枚数:</span>
                    <span id="total-count" class="font-bold text-lg">0</span>
                </div>
                <div class="flex justify-between border-b pb-1">
                    <span>選択中:</span>
                    <span id="selected-count" class="font-bold text-lg text-blue-600">0</span>
                </div>
                <div class="flex justify-between items-center pt-1">
                    <span>シャッフル回数:</span>
                    <div class="flex items-center space-x-2">
                        <span id="shuffle-count" class="font-bold text-lg text-indigo-600">0</span>
                        <button id="reset-shuffle-count-btn" class="text-xs bg-gray-300 hover:bg-gray-400 px-2 py-1 rounded">リセット</button>
                    </div>
                </div>
            </div>

            <div class="bg-gray-300 p-3 rounded-lg space-y-2">
                <h3 class="font-bold text-gray-700">表示設定</h3>
                <div class="flex items-center space-x-2">
                    <span class="text-xs font-bold text-gray-600">ズーム:</span>
                    <input type="range" id="zoom-slider" min="0.3" max="2.0" step="0.1" value="1.0" class="w-full cursor-pointer">
                    <span id="zoom-value" class="text-xs font-bold w-10 text-right">100%</span>
                </div>
                <div class="flex items-center space-x-2">
                    <button id="zoom-reset-btn" class="text-xs bg-white hover:bg-gray-100 px-2 py-1 rounded shadow w-full">100%に戻す</button>
                </div>
            </div>

            <!-- プロトコル作成UI -->
            <div class="bg-orange-100 p-4 rounded-lg space-y-3 border border-orange-200 mb-6">
                <h3 class="font-bold text-orange-800 text-lg">プロトコル作成 (一連の流れ)</h3>
                <div class="flex space-x-2">
                    <select id="protocol-action-select" class="flex-1 p-2 border border-orange-300 rounded text-sm bg-white">
                        <option value="randomCutHorizon">ランダムカット(横)</option>
                        <option value="randomCutVertical">ランダムカット(縦)</option>
                        <option value="pileScrambleCol">パイルスクランブル(列)</option>
                        <option value="pileScrambleRow">パイルスクランブル(行)</option>
                        <option value="flip">裏返す/表にする</option>
                    </select>
                    <input type="number" id="protocol-action-count" value="1" min="1" 
                        class="w-20 p-2 border border-orange-300 rounded text-sm text-center" 
                        title="回数">
                </div>
                <button id="add-to-protocol-btn" 
                        class="w-full bg-orange-500 hover:bg-orange-600 text-white font-bold py-2 px-3 rounded shadow">
                    ＋ 手順に追加
                </button>
                
                <!-- プロトコルリスト -->
                <div id="protocol-list" 
                    class="bg-gray-50 p-3 rounded border border-gray-300 min-h-[150px] max-h-[300px] overflow-y-auto">
                    <p class="text-sm text-gray-400 text-center py-4 empty-msg">手順がありません</p>
                </div>

                <div class="flex space-x-2">
                    <button id="run-protocol-btn" 
                            class="flex-1 bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-3 rounded shadow">
                        ▶ 実行
                    </button>
                    <button id="clear-protocol-btn" 
                            class="flex-1 bg-gray-400 hover:bg-gray-500 text-white font-bold py-2 px-3 rounded shadow">
                        クリア
                    </button>
                </div>
            </div>

            <div class="bg-teal-100 p-3 rounded-lg space-y-2">
                <h3 class="font-bold text-teal-800 text-sm">テンプレートから追加</h3>
                <select id="template-select" class="w-full p-2 border border-teal-300 rounded text-sm bg-white">
                    <option value="adj_graph_g">隣接コミットメント (グラフG)</option>
                </select>
                <button id="apply-template-btn" class="w-full bg-teal-600 hover:bg-teal-700 text-white font-bold py-2 px-4 rounded shadow text-sm">
                    配置
                </button>
            </div>

            <button id="add-card-btn" class="w-full bg-blue-500 hover:bg-blue-600 text-white font-bold py-3 px-4 rounded-lg shadow-md transition-transform transform hover:scale-105">
                カードを追加
            </button>

            <button id="group-select-toggle-btn" class="w-full bg-gray-500 hover:bg-gray-600 text-white font-bold py-2 px-4 rounded-lg shadow-md">
                グループ選択: OFF
            </button>

            <!-- グリッド設定 -->
            <div class="bg-gray-300 p-3 rounded-lg space-y-2">
                <h3 class="font-bold text-gray-700">グリッド設定</h3>
                <label class="flex items-center space-x-2 cursor-pointer">
                    <input type="checkbox" id="snap-to-grid-check" class="form-checkbox h-5 w-5 text-blue-600">
                    <span class="text-gray-780 font-semibold text-xs">マス目にスナップ</span>
                </label>
                <label class="flex items-center space-x-2 cursor-pointer">
                    <input type="checkbox" id="show-grid-check" class="form-checkbox h-5 w-5 text-blue-600">
                    <span class="text-gray-780 font-semibold text-xs">マス目を表示</span>
                </label>
            </div>
            
            <div class="pt-4 border-t border-gray-300 space-y-2">
                <div class="bg-indigo-100 p-2 rounded-lg mb-2">
                    <div class="flex flex-col space-y-2 mb-2">
                        <button id="random-cut-Horizon-btn" class="w-full bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-2 px-4 rounded-lg shadow-md text-sm">
                            ランダムカット(横)
                        </button>
                        <button id="random-cut-Vertical-btn" class="w-full bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-2 px-4 rounded-lg shadow-md text-sm">
                            ランダムカット(縦)
                        </button>
                    </div>
                </div>

                <div class="bg-pink-100 p-2 rounded-lg mb-2">
                    <h3 class="text-xs font-bold text-pink-800 mb-1 ml-1">束シャッフル (Scramble)</h3>
                    <div class="flex flex-col space-y-2 mb-2">
                        <button id="pile-scramble-col-btn" class="w-full bg-pink-600 hover:bg-pink-700 text-white font-bold py-2 px-4 rounded-lg shadow-md text-sm">
                            垂直パイルスクランブル
                        </button>
                        <button id="pile-scramble-row-btn" class="w-full bg-pink-600 hover:bg-pink-700 text-white font-bold py-2 px-4 rounded-lg shadow-md text-sm">
                            水平パイルスクランブル
                        </button>
                    </div>
                </div>
                
                 <button id="export-layout-btn" class="w-full bg-green-500 hover:bg-green-600 text-white font-bold py-2 px-4 rounded-lg shadow-md">
                    レイアウトをエクスポート
                </button>
                 <button id="import-layout-btn" class="w-full bg-purple-500 hover:bg-purple-600 text-white font-bold py-2 px-4 rounded-lg shadow-md">
                    レイアウトをインポート
                </button>
                <input type="file" id="import-file-input" class="hidden" accept=".json">
                <p id="feedback-msg" class="text-center text-green-700 font-semibold opacity-0 h-4"></p>
                <button id="delete-selected-btn" class="w-full bg-yellow-500 hover:bg-yellow-600 text-white font-bold py-2 px-4 rounded-lg shadow-md">
                    選択したカードを削除
                </button>
                <button id="clear-layout-btn" class="w-full bg-red-500 hover:bg-red-600 text-white font-bold py-2 px-4 rounded-lg shadow-md">
                    全カードを削除
                </button>
            </div>
        </aside>
    </div>

    <!-- カード追加モーダル -->
    <dialog id="add-card-modal" class="p-8 bg-white rounded-xl shadow-2xl w-full max-w-xl" style="zoom: 150%;">
        <form id="add-card-form">
            <h3 class="text-2xl font-bold mb-6 text-gray-800">新しいカードを作成</h3>
            <fieldset class="mb-4">
                <legend class="font-semibold mb-2 text-gray-700">カードの種類</legend>
                <div class="flex space-x-4">
                    <label class="flex items-center space-x-2"><input type="radio" name="cardType" value="playingCard" checked class="form-radio h-5 w-5 text-blue-600"><span class="text-gray-700">トランプ</span></label>
                    <label class="flex items-center space-x-2"><input type="radio" name="cardType" value="colorCard" class="form-radio h-5 w-5 text-blue-600"><span class="text-gray-700">色カード</span></label>
                </div>
            </fieldset>
            <fieldset id="playing-card-options" class="space-y-4">
                <div>
                    <label for="suit" class="block font-semibold mb-1 text-gray-700">スート (マーク)</label>
                    <select id="suit" name="suit" class="w-full p-2 border border-gray-300 rounded-md focus:ring-2 focus:ring-blue-500 focus:border-blue-500">
                        <option value="♠">スペード (♠)</option><option value="♥">ハート (♥)</option><option value="♦">ダイヤ (♦)</option><option value="♣">クラブ (♣)</option>
                    </select>
                </div>
                <div>
                    <label for="card-count" class="block font-semibold mb-1 text-gray-700">作製枚数</label>
                    <input type="number" id="card-count" name="cardCount" value="1" min="1" class="w-full p-2 border border-gray-300 rounded-md focus:ring-2 focus:ring-blue-500 focus:border-blue-500">
                </div>
            </fieldset>
            <fieldset id="color-card-options" class="hidden">
                <div>
                    <label for="color" class="block font-semibold mb-1 text-gray-700">色を選択</label>
                    <input type="color" id="color" name="color" value="#ff0000" class="w-full h-12 p-1 border border-gray-300 rounded-md cursor-pointer">
                </div>
            </fieldset>

            <!-- ★★★ 共通設定エリア（枚数・行列設定） ★★★ -->
            <div class="mt-4 p-4 bg-gray-100 rounded-md">
                <label for="card-count" class="block font-semibold mb-1 text-gray-700">作製枚数 (N)</label>
                <input type="number" id="card-count" name="cardCount" value="1" min="1" class="w-full p-2 border border-gray-300 rounded-md focus:ring-2 focus:ring-blue-500 focus:border-blue-500 mb-2">
                
                <label class="flex items-center space-x-2 cursor-pointer mt-2">
                    <input type="checkbox" id="create-as-matrix" name="createAsMatrix" class="form-checkbox h-5 w-5 text-blue-600">
                    <span class="text-gray-700 font-semibold">N × N (行列) で配置</span>
                </label>
                <p class="text-xs text-gray-500 mt-1">※チェックを入れると、N行N列の合計N²枚が作成されます。</p>
            </div>

            <div class="mt-8 flex justify-end space-x-4">
                <button type="button" id="cancel-btn" class="px-6 py-2 bg-gray-200 text-gray-800 rounded-md hover:bg-gray-300">キャンセル</button>
                <button type="submit" class="px-6 py-2 bg-green-500 text-white rounded-md hover:bg-green-600 font-semibold">作成</button>
            </div>
        </form>
    </dialog>

    <!-- 確認モーダル -->
    <dialog id="confirm-modal" class="p-6 bg-white rounded-lg shadow-xl w-full max-w-sm" style="zoom: 160%;">
        <h3 class="text-lg font-bold text-gray-900 mb-4">確認</h3>
        <p id="confirm-message" class="text-gray-700 mb-6">本当に実行しますか？</p>
        <div class="flex justify-end space-x-4">
            <button id="confirm-cancel-btn" class="px-4 py-2 bg-gray-200 text-gray-800 rounded-md hover:bg-gray-300">いいえ</button>
            <button id="confirm-ok-btn" class="px-4 py-2 bg-red-500 text-white rounded-md hover:bg-red-600">はい</button>
        </div>
    </dialog>

<script>
    document.addEventListener('DOMContentLoaded', () => {
        const {icpRenderer} = require('electron');
        const board = document.getElementById('board');
        const scrollContainer = document.getElementById('scroll-container');
        const scrollWrapper = document.getElementById('scroll-wrapper');
        const canvas = document.getElementById('canvas');
        const addCardBtn = document.getElementById('add-card-btn');
        const modal = document.getElementById('add-card-modal');
        const addCardForm = document.getElementById('add-card-form');
        const cancelBtn = document.getElementById('cancel-btn');
        const cardTypeRadios = document.querySelectorAll('input[name="cardType"]');
        const playingCardOptions = document.getElementById('playing-card-options');
        const colorCardOptions = document.getElementById('color-card-options');
        const clearLayoutBtn = document.getElementById('clear-layout-btn');
        const feedbackMsg = document.getElementById('feedback-msg');
        const confirmModal = document.getElementById('confirm-modal');
        const confirmMessage = document.getElementById('confirm-message');
        const confirmOkBtn = document.getElementById('confirm-ok-btn');
        const confirmCancelBtn = document.getElementById('confirm-cancel-btn');
        const exportLayoutBtn = document.getElementById('export-layout-btn');
        const importLayoutBtn = document.getElementById('import-layout-btn');
        const importFileInput = document.getElementById('import-file-input');
        const groupSelectToggleBtn = document.getElementById('group-select-toggle-btn');
        const deleteSelectedBtn = document.getElementById('delete-selected-btn');
        const randomCutHorizonBtn = document.getElementById('random-cut-Horizon-btn');
        const randomCutVerticalBtn = document.getElementById('random-cut-Vertical-btn');
        const pileScrambleColBtn = document.getElementById('pile-scramble-col-btn');
        const pileScrambleRowBtn = document.getElementById('pile-scramble-row-btn');
        //テンプレート用要素
        const templateSelect = document.getElementById('template-select');
        const applyTemplateBtn = document.getElementById('apply-template-btn');        
        const snapToGridCheck = document.getElementById('snap-to-grid-check');
        const showGridCheck = document.getElementById('show-grid-check');
        //行列作成チェックボックス
        const createAsMatrixCheck = document.getElementById('create-as-matrix');
        // ★★★ カウンター要素の取得 ★★★
        const totalCountEl = document.getElementById('total-count');
        const selectedCountEl = document.getElementById('selected-count');
        const shuffleCountEl = document.getElementById('shuffle-count');
        const resetShuffleBtn = document.getElementById('reset-shuffle-count-btn');
        //ズームUI
        const zoomSlider = document.getElementById('zoom-slider');
        const zoomValue = document.getElementById('zoom-value');
        const zoomResetBtn = document.getElementById('zoom-reset-btn');
        const selectionBox = document.getElementById('selection-box');
        const updateBtn = document.getElementById('update-btn');
        const controlPanel = document.getElementById('control-panel');
        const resizer = document.getElementById('resizer');
        // デモ用の簡易実装
        const protocolActionSelect = document.getElementById('protocol-action-select');
        const protocolActionCount = document.getElementById('protocol-action-count');
        const addToProtocolBtn = document.getElementById('add-to-protocol-btn');
        const protocolList = document.getElementById('protocol-list');
        const runProtocolBtn = document.getElementById('run-protocol-btn');
        const clearProtocolBtn = document.getElementById('clear-protocol-btn');

        let protocolQueue = [];
        let zIndexCounter = 1;
        let confirmCallback = null;
        const selectedCards = new Set();
        let isGroupSelectMode = false;
        let shuffleCounter = 0; // シャッフル回数
        let currentZoom = 1.0; //ズーム状態の管理
        // 矩形選択用の変数
        let isSelecting = false;
        let selectionStart = { x: 0, y: 0 };
        let selectionEnd = { x: 0, y: 0 };
        //リサイズ機能の調整するかの判定
        let isResizing = false;   
        const GRID_WIDTH = 120;
        const GRID_HEIGHT = 170;

        scrollContainer.scrollTop = (canvas.scrollHeight - scrollContainer.clientHeight) / 2;
        scrollContainer.scrollLeft = (canvas.scrollWidth - scrollContainer.clientWidth) / 2;

        if(updateBtn) {
            updateBtn.addEventListener('click', () => {
                icpRenderer.send('manual-update-check');
            });
        }
        
        // --- イベントリスナー ---
        addCardBtn.addEventListener('click', () => modal.showModal());
        cancelBtn.addEventListener('click', () => modal.close());
        modal.addEventListener('click', (e) => { if (e.target === modal) modal.close(); });

        cardTypeRadios.forEach(radio => {
            radio.addEventListener('change', (e) => {
                playingCardOptions.classList.toggle('hidden', e.target.value !== 'playingCard');
                colorCardOptions.classList.toggle('hidden', e.target.value !== 'colorCard');
            });
        });
        
        showGridCheck.addEventListener('change', (e) => {
            canvas.classList.toggle('show-grid', e.target.checked);
        });

        // ★★★ シャッフル回数リセット ★★★
        resetShuffleBtn.addEventListener('click', () => {
            shuffleCounter = 0;
            updateStatus();
        });

        // ★★★ テンプレート配置処理 ★★★
        applyTemplateBtn.addEventListener('click', () => {
            const templateType = templateSelect.value;
            if (templateType === 'adj_graph_g') {
                applyAdjacencyCommitmentGraphG();
            }
        });

        addCardForm.addEventListener('submit', (e) => {
            e.preventDefault();
            try {
                const formData = new FormData(addCardForm);
                const cardData = Object.fromEntries(formData.entries());
                const count = parseInt(cardData.cardCount) || 1;
                const isMatrix = createAsMatrixCheck ? createAsMatrixCheck.checked : false;

                // ★★★ 修正: n を count から取得 ★★★
                const n = count;

                if (isMatrix) {
                    // 行列配置 (N×N)
                    const totalWidth = n * GRID_WIDTH;
                    const totalHeight = n * GRID_HEIGHT;
                    const startX = scrollContainer.scrollLeft + (scrollContainer.clientWidth / 2) - (totalWidth / 2);
                    const startY = scrollContainer.scrollTop + (scrollContainer.clientHeight / 2) - (totalHeight / 2);

                    for (let r = 0; r < n; r++) {
                        for (let c = 0; c < n; c++) {
                            const singleCardData = { ...cardData };
                            let left = startX + c * GRID_WIDTH;
                            let top = startY + r * GRID_HEIGHT;

                            if (snapToGridCheck.checked) {
                                left = Math.round(left / GRID_WIDTH) * GRID_WIDTH;
                                top = Math.round(top / GRID_HEIGHT) * GRID_HEIGHT;
                            }

                            singleCardData.left = `${left}px`;
                            singleCardData.top = `${top}px`;
                            singleCardData.zIndex = zIndexCounter++;
                            createCard(singleCardData);
                        }
                    }
                } else {
                    // 通常配置（重ねて配置）
                    for (let i = 0; i < n; i++) {
                        const singleCardData = { ...cardData };
                        const offsetX = (i % 5) * 20 - 40;
                        const offsetY = Math.floor(i / 5) * 20 - 20;

                        let left = scrollContainer.scrollLeft + (scrollContainer.clientWidth / 2) - 56 + offsetX;
                        let top = scrollContainer.scrollTop + (scrollContainer.clientHeight / 2) - 80 + offsetY;
                        
                        if (snapToGridCheck.checked) {
                            left = Math.round(left / GRID_WIDTH) * GRID_WIDTH;
                            top = Math.round(top / GRID_HEIGHT) * GRID_HEIGHT;
                        }

                        singleCardData.left = `${left}px`;
                        singleCardData.top = `${top}px`;
                        singleCardData.zIndex = zIndexCounter++;
                        createCard(singleCardData);
                    }
                }
                
                updateStatus();
                modal.close();
                addCardForm.reset();
                
                // UI状態のリセット
                const playingRadio = document.querySelector('input[name="cardType"][value="playingCard"]');
                if (playingRadio) playingRadio.checked = true;
                    
                document.getElementById('card-count').value = '1';
                if (createAsMatrixCheck) createAsMatrixCheck.checked = false;
                playingCardOptions.classList.remove('hidden');
                colorCardOptions.classList.add('hidden');
            } catch (error) {
                alert("カード作成中にエラーが発生しました: " + error.message);
            }
        });

        clearLayoutBtn.addEventListener('click', () => {
             showConfirm('本当にすべてのカードを削除しますか？', () => {
                canvas.innerHTML = '';
                zIndexCounter = 1;
                clearSelection();
                updateStatus(); // ★★★ 更新
            });
        });

        deleteSelectedBtn.addEventListener('click', () => {
            if (selectedCards.size === 0) {
                showFeedback('削除するカードが選択されていません。');
                return;
            }

            showConfirm(`選択した${selectedCards.size}枚のカードを本当に削除しますか？`, () => {
                selectedCards.forEach(card => {
                    card.remove();
                });
                clearSelection();
                showFeedback('選択したカードを削除しました。');
                updateStatus(); // ★★★ 更新
            });
        });

        randomCutHorizonBtn.addEventListener('click', () => {
            if (selectedCards.size < 2) {
                showFeedback('ランダムカットするには2枚以上選択してください。');
                return;
            }

            const cardsArray = Array.from(selectedCards);

            // 座標に基づいてソート（左上から右下へ）
            cardsArray.sort((a, b) => {
                const ay = parseInt(a.style.top || 0);
                const by = parseInt(b.style.top || 0);
                // 多少のズレは同じ行とみなす
                if (Math.abs(ay - by) > GRID_HEIGHT / 2) {
                    return ay - by;
                }
                const ax = parseInt(a.style.left || 0);
                const bx = parseInt(b.style.left || 0);
                return ax - bx;
            });

            // 各カードの位置を記録
            const positions = cardsArray.map(card => ({
                left: card.style.left,
                top: card.style.top
            }));

            const n = cardsArray.length;
            
            // ★★★ 修正: 1枚だけ右に移動（右シフト量1固定） ★★★
            const shift = 1;

            // 各カードを新しい位置に移動（右シフト）
            cardsArray.forEach((card, index) => {
                // 右シフト: index のカードを (index + shift) % n の位置へ
                const newPosIndex = (index + shift) % n;
                
                card.style.left = positions[newPosIndex].left;
                card.style.top = positions[newPosIndex].top;
                card.style.zIndex = zIndexCounter++;
            });

            showFeedback('1枚右に移動しました');
        });

        randomCutVerticalBtn.addEventListener('click', () => {
            if (selectedCards.size < 2) {
                showFeedback('ランダムカットするには2枚以上選択してください。');
                return;
            }

            const cardsArray = Array.from(selectedCards);

            // 縦方向: 同じ列（X座標が近い）のカードをグループ化
            const columns = new Map();
            cardsArray.forEach(card => {
                const x = parseInt(card.style.left || 0);
                const colKey = Math.round(x / GRID_WIDTH);
                if (!columns.has(colKey)) {
                    columns.set(colKey, []);
                }
                columns.get(colKey).push(card);
            });

            // 各列ごとに縦方向カット（1枚下移動）
            columns.forEach(colCards => {
                if (colCards.length < 2) return;
                
                // Y座標でソート
                colCards.sort((a, b) => {
                    return parseInt(a.style.top || 0) - parseInt(b.style.top || 0);
                });

                const positions = colCards.map(card => ({
                    left: card.style.left,
                    top: card.style.top
                }));

                const n = colCards.length;
                const shift = 1; // 1枚下移動

                colCards.forEach((card, index) => {
                    const newPosIndex = (index + shift) % n;
                    card.style.left = positions[newPosIndex].left;
                    card.style.top = positions[newPosIndex].top;
                    card.style.zIndex = zIndexCounter++;
                });
            });

            showFeedback('縦方向に1枚下移動しました');
        });

        // ★★★ パイルスクランブル（列）の実装 ★★★
        pileScrambleColBtn.addEventListener('click', () => {
            if (selectedCards.size === 0) {
                showFeedback('カードを選択してください。');
                return;
            }
            const cardsArray = Array.from(selectedCards);
            
            // X座標で列をグループ化
            const colMap = new Map();
            cardsArray.forEach(card => {
                const x = parseInt(card.style.left || 0);
                // 多少のズレを許容して列をまとめる
                const colKey = Math.round(x / GRID_WIDTH);
                if (!colMap.has(colKey)) colMap.set(colKey, []);
                colMap.get(colKey).push(card);
            });

            const colKeys = Array.from(colMap.keys()).sort((a, b) => a - b);
            const n = colKeys.length;
            if (n < 2) {
                showFeedback('シャッフルする列が2つ以上必要です。');
                return;
            }

            // 列の元の代表X座標リストを取得
            const originalXPositions = colKeys.map(key => {
                return colMap.get(key)[0].style.left;
            });

            // ランダムな順列（シャッフル）を作成
            // フィッシャー–イェーツのシャッフル
            const indices = Array.from({length: n}, (_, i) => i);
            for (let i = n - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [indices[i], indices[j]] = [indices[j], indices[i]];
            }

            // 各列を新しい位置へ移動
            colKeys.forEach((oldKey, originalIndex) => {
                const targetIndex = indices[originalIndex]; // シャッフル後のインデックス
                const newX = originalXPositions[targetIndex]; // そのインデックスのX座標
                
                const cardsInCol = colMap.get(oldKey);
                cardsInCol.forEach(card => {
                    card.style.left = newX;
                    card.style.zIndex = zIndexCounter++;
                });
            });

            incrementShuffleCount();
            showFeedback(`パイルスクランブル(列)しました`);
        });

        // ★★★ パイルスクランブル（行）の実装 ★★★
        pileScrambleRowBtn.addEventListener('click', () => {
            if (selectedCards.size === 0) {
                showFeedback('カードを選択してください。');
                return;
            }
            const cardsArray = Array.from(selectedCards);
            
            // Y座標で行をグループ化
            const rowMap = new Map();
            cardsArray.forEach(card => {
                const y = parseInt(card.style.top || 0);
                const rowKey = Math.round(y / GRID_HEIGHT);
                if (!rowMap.has(rowKey)) rowMap.set(rowKey, []);
                rowMap.get(rowKey).push(card);
            });

            const rowKeys = Array.from(rowMap.keys()).sort((a, b) => a - b);
            const n = rowKeys.length;
            if (n < 2) {
                showFeedback('シャッフルする行が2つ以上必要です。');
                return;
            }

            // 行の元の代表Y座標リストを取得
            const originalYPositions = rowKeys.map(key => {
                return rowMap.get(key)[0].style.top;
            });

            // ランダムな順列を作成
            const indices = Array.from({length: n}, (_, i) => i);
            for (let i = n - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [indices[i], indices[j]] = [indices[j], indices[i]];
            }

            // 各行を新しい位置へ移動
            rowKeys.forEach((oldKey, originalIndex) => {
                const targetIndex = indices[originalIndex];
                const newY = originalYPositions[targetIndex];
                
                const cardsInRow = rowMap.get(oldKey);
                cardsInRow.forEach(card => {
                    card.style.top = newY;
                    card.style.zIndex = zIndexCounter++;
                });
            });

            incrementShuffleCount();
            showFeedback(`パイルスクランブル(行)しました`);
        });


        confirmOkBtn.addEventListener('click', () => {
            if (confirmCallback) confirmCallback();
            confirmModal.close();
        });
        confirmCancelBtn.addEventListener('click', () => confirmModal.close());

        exportLayoutBtn.addEventListener('click', exportLayout);
        importLayoutBtn.addEventListener('click', () => importFileInput.click());
        importFileInput.addEventListener('change', importLayout);
        
        board.addEventListener('mousedown', (e) => {
            if (!isGroupSelectMode && (e.target === board || e.target === canvas)) {
                clearSelection();
            }
        });

        groupSelectToggleBtn.addEventListener('click', () => {
            isGroupSelectMode = !isGroupSelectMode;
            groupSelectToggleBtn.classList.toggle('mode-active', isGroupSelectMode);
            groupSelectToggleBtn.textContent = `グループ選択: ${isGroupSelectMode ? 'ON' : 'OFF'}`;
            if (!isGroupSelectMode) {
                clearSelection();
            }
        });

        //矩形選択のイベントリスナー (boardに対してmousedown)
        scrollContainer.addEventListener('mousedown', (e) => {
            // カードやコントロールがターゲットの場合は何もしない（カードのドラッグ等を優先）
            // e.target が board または canvas の場合のみ矩形選択を開始
            if (e.target !== scrollContainer && e.target !== canvas) return;
            if (e.button !== 0) return;

            isSelecting = true;
            
            const containerRect = scrollContainer.getBoundingClientRect();
            // ズーム倍率を考慮した座標計算
            const startX = (e.clientX - containerRect.left + scrollContainer.scrollLeft) / currentZoom;
            const startY = (e.clientY - containerRect.top + scrollContainer.scrollTop) / currentZoom;
            
            selectionStart = { x: startX, y: startY };
            selectionEnd = { x: startX, y: startY };
            
            selectionBox.style.left = `${startX}px`;
            selectionBox.style.top = `${startY}px`;
            selectionBox.style.width = '0px';
            selectionBox.style.height = '0px';
            selectionBox.style.display = 'block';

            document.addEventListener('mousemove', onSelectionMove);
            document.addEventListener('mouseup', onSelectionUp);
        });

        // リサイザー
        resizer.addEventListener('mousedown', (e) => {
            e.preventDefault();
            isResizing = true;
            resizer.classList.add('resizing');
            document.body.style.cursor = 'col-resize';
            document.addEventListener('mousemove', handleResizeMove);
            document.addEventListener('mouseup', handleResizeUp);
        });

        zoomSlider.addEventListener('input', (e) => {
            setZoom(e.target.value);
        });

        zoomResetBtn.addEventListener('click', () => {
            setZoom(1.0);
        });

        addToProtocolBtn.addEventListener('click', () => {
            const action = protocolActionSelect.value;
            const count = parseInt(protocolActionCount.value) || 1;
            protocolQueue.push({ action, count });
            updateProtocolListDisplay();
        });

        clearProtocolBtn.addEventListener('click', () => {
            protocolQueue = [];
            updateProtocolListDisplay();
        });

        runProtocolBtn.addEventListener('click', runProtocol);


        // --- 関数定義 ---

        // ★★★ テンプレート：隣接コミットメント (グラフG) ★★★
        function applyAdjacencyCommitmentGraphG() {
            /* グラフGの隣接行列 (5x5)
               頂点: 1,2,3,4,5
               辺: (1,2), (1,5), (2,3), (3,4), (4,5)
               
               行列:
                 1 2 3 4 5
               1 H D C C D
               2 D H D C C
               3 C D H D C
               4 C C D H D
               5 D C C D H
               
               H=ハート(対角), D=ダイヤ(1), C=クラブ(0)
            */
            const matrix = [
                ['♥', '♦', '♣', '♣', '♦'], // 1行目
                ['♦', '♥', '♦', '♣', '♣'], // 2行目
                ['♣', '♦', '♥', '♦', '♣'], // 3行目
                ['♣', '♣', '♦', '♥', '♦'], // 4行目
                ['♦', '♣', '♣', '♦', '♥']  // 5行目
            ];

            const startX = scrollContainer.scrollLeft + (scrollContainer.clientWidth / 2) - (2.5 * GRID_WIDTH);
            const startY = scrollContainer.scrollTop + (scrollContainer.clientHeight / 2) - (2.5 * GRID_HEIGHT);

            for (let r = 0; r < 5; r++) {
                for (let c = 0; c < 5; c++) {
                    const suit = matrix[r][c];
                    let left = startX + c * GRID_WIDTH;
                    let top = startY + r * GRID_HEIGHT;

                    // グリッドスナップが有効なら位置を補正
                    if (snapToGridCheck.checked) {
                        left = Math.round(left / GRID_WIDTH) * GRID_WIDTH;
                        top = Math.round(top / GRID_HEIGHT) * GRID_HEIGHT;
                    }

                    const cardData = {
                        cardType: 'playingCard',
                        suit: suit,
                        left: `${left}px`,
                        top: `${top}px`,
                        zIndex: zIndexCounter++
                    };
                    createCard(cardData);
                }
            }
            updateStatus();
            showFeedback('隣接コミットメント(グラフG)を配置しました');
        }
        
        // ★★★ ステータス更新関数 ★★★
        function updateStatus() {
            const cards = canvas.querySelectorAll('.card-container');
            totalCountEl.textContent = cards.length;
            selectedCountEl.textContent = selectedCards.size;
            shuffleCountEl.textContent = shuffleCounter;
        }

        // ★★★ シャッフル回数インクリメント ★★★
        function incrementShuffleCount() {
            shuffleCounter++;
            updateStatus();
        }

        function showConfirm(message, onConfirm) {
            confirmMessage.textContent = message;
            confirmCallback = onConfirm;
            confirmModal.showModal();
        }
        
        function showFeedback(message) {
            feedbackMsg.textContent = message;
            feedbackMsg.style.opacity = 1;
            setTimeout(() => { feedbackMsg.style.opacity = 0; }, 2500);
        }

        function clearSelection() {
            selectedCards.forEach(card => card.classList.remove('selected'));
            selectedCards.clear();
            updateStatus(); // ★★★ 更新
        }

        function toggleSelection(card) {
            if (selectedCards.has(card)) {
                selectedCards.delete(card);
                card.classList.remove('selected');
            } else {
                selectedCards.add(card);
                card.classList.add('selected');
            }
            updateStatus(); // ★★★ 更新
        }

        function createCard(data) {
            const cardContainer = document.createElement('div');
            cardContainer.className = 'card-container absolute w-28 h-40 cursor-grab select-none';
            cardContainer.style.left = data.left;
            cardContainer.style.top = data.top;
            cardContainer.style.zIndex = data.zIndex;
            cardContainer.dataset.cardType = data.cardType;

            const cardInner = document.createElement('div');
            cardInner.className = 'card-inner';

            const cardFront = document.createElement('div');
            cardFront.className = 'card-front bg-white shadow-lg border-2 border-gray-300';
            
            const cardBack = document.createElement('div');
            cardBack.className = 'card-back text-5xl font-bold';
            cardBack.textContent = '?';

            if (data.cardType === 'playingCard') {
                const { suit } = data;
                cardContainer.dataset.suit = suit;
                const color = (suit === '♥' || suit === '♦') ? 'text-red-600' : 'text-black';
                cardFront.innerHTML = `<div class="w-full h-full flex items-center justify-center text-7xl font-bold ${color}">${suit}</div>`;
            } else {
                cardContainer.dataset.color = data.color;
                cardFront.style.backgroundColor = data.color;
                cardFront.style.border = '2px solid rgba(0,0,0,0.2)';
            }
            
            if (data.flipped) cardContainer.classList.add('flipped');
            if (data.selected) toggleSelection(cardContainer); // ここでupdateStatusが呼ばれるが、ループ中のため負荷が気になる場合は調整
            
            cardInner.appendChild(cardFront);
            cardInner.appendChild(cardBack);
            cardContainer.appendChild(cardInner);

            const deleteBtn = document.createElement('div');
            deleteBtn.className = 'delete-btn';
            deleteBtn.innerHTML = '&times;';
            deleteBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                showConfirm('このカードを削除しますか？', () => {
                    cardContainer.remove();
                    if(selectedCards.has(cardContainer)) {
                        selectedCards.delete(cardContainer);
                    }
                    updateStatus(); // ★★★ 更新
                });
            });
            cardContainer.appendChild(deleteBtn);
            canvas.appendChild(cardContainer);

            makeDraggable(cardContainer);
            
            cardContainer.addEventListener('dblclick', () => cardContainer.classList.toggle('flipped'));
            let lastTap = 0;
            cardContainer.addEventListener('touchend', () => {
                if (cardContainer.didMove) return;
                const currentTime = new Date().getTime();
                if (currentTime - lastTap < 300) {
                    cardContainer.classList.toggle('flipped');
                }
                lastTap = currentTime;
            });
            
            cardContainer.addEventListener('contextmenu', e => e.preventDefault());
            
            if (parseInt(data.zIndex) >= zIndexCounter) {
                zIndexCounter = parseInt(data.zIndex) + 1;
            }
        }
        
        function makeDraggable(element) {
            let initialPositions = new Map();
            let dragStartPos = null;
            let didMove = false;

            function onPointerDown(e) {
                if (e.target.classList.contains('delete-btn')) return;
                const isTouchEvent = e.type === 'touchstart';
                if (!isTouchEvent) e.preventDefault();

                element.didMove = false;
                didMove = false;
                const startX = isTouchEvent ? e.touches[0].clientX : e.clientX;
                const startY = isTouchEvent ? e.touches[0].clientY : e.clientY;
                dragStartPos = { x: startX, y: startY };

                document.addEventListener(isTouchEvent ? 'touchmove' : 'mousemove', onPointerMove, { passive: false });
                document.addEventListener(isTouchEvent ? 'touchend' : 'mouseup', onPointerUp);
            }

            function onPointerMove(e) {
                if (dragStartPos === null) return;
                const isTouchEvent = e.type === 'touchmove';
                if (isTouchEvent) e.preventDefault();

                const moveX = isTouchEvent ? e.touches[0].clientX : e.clientX;
                const moveY = isTouchEvent ? e.touches[0].clientY : e.clientY;

                if (!didMove && (Math.abs(moveX - dragStartPos.x) > 5 || Math.abs(moveY - dragStartPos.y) > 5)) {
                    didMove = true;
                    element.didMove = true;
                    
                    if (!selectedCards.has(element)) {
                        if (!isGroupSelectMode) {
                            clearSelection();
                        }
                        selectedCards.add(element);
                        element.classList.add('selected');
                        updateStatus(); // ★★★ 更新
                    }

                    initialPositions.clear();
                    selectedCards.forEach(card => {
                        card.classList.add('grabbing');
                        card.style.zIndex = zIndexCounter++;
                        initialPositions.set(card, { left: card.offsetLeft, top: card.offsetTop });
                    });
                }

                if (didMove) {
                    const deltaX = moveX - dragStartPos.x;
                    const deltaY = moveY - dragStartPos.y;
                    selectedCards.forEach(card => {
                        const initialPos = initialPositions.get(card);
                        if (initialPos) {
                            let x = initialPos.left + deltaX;
                            let y = initialPos.top + deltaY;
                            
                            x = Math.max(0, Math.min(x, canvas.clientWidth - card.offsetWidth));
                            y = Math.max(0, Math.min(y, canvas.clientHeight - card.offsetHeight));
                            
                            card.style.left = `${x}px`;
                            card.style.top = `${y}px`;
                        }
                    });
                }
            }

            function onPointerUp(e) {
                if (!didMove) {
                    const isTouchEvent = e.type.startsWith('touch');
                    if (isGroupSelectMode) {
                        toggleSelection(element);
                    } else {
                        if (isTouchEvent || !e.shiftKey) {
                            clearSelection();
                        }
                        toggleSelection(element);
                    }
                } else {
                    if (snapToGridCheck.checked) {
                        selectedCards.forEach(card => {
                            let currentLeft = parseInt(card.style.left || 0);
                            let currentTop = parseInt(card.style.top || 0);

                            let snapLeft = Math.round(currentLeft / GRID_WIDTH) * GRID_WIDTH;
                            let snapTop = Math.round(currentTop / GRID_HEIGHT) * GRID_HEIGHT;

                            snapLeft = Math.max(0, Math.min(snapLeft, canvas.clientWidth - card.offsetWidth));
                            snapTop = Math.max(0, Math.min(snapTop, canvas.clientHeight - card.offsetHeight));

                            card.style.left = `${snapLeft}px`;
                            card.style.top = `${snapTop}px`;
                        });
                    }
                }

                selectedCards.forEach(card => card.classList.remove('grabbing'));
                dragStartPos = null;
                initialPositions.clear();
                
                const isTouchEvent = e.type === 'touchend';
                document.removeEventListener(isTouchEvent ? 'touchmove' : 'mousemove', onPointerMove);
                document.removeEventListener(isTouchEvent ? 'touchend' : 'mouseup', onPointerUp);
            }

            element.addEventListener('mousedown', onPointerDown);
            element.addEventListener('touchstart', onPointerDown, { passive: false });
        }

        function exportLayout() {
            const cards = Array.from(canvas.querySelectorAll('.card-container'));
            if (cards.length === 0) {
                showFeedback('エクスポートするカードがありません。');
                return;
            }
            const layoutData = cards.map(card => {
                const cardData = { ...card.dataset };
                cardData.left = card.style.left;
                cardData.top = card.style.top;
                cardData.zIndex = card.style.zIndex;
                cardData.flipped = card.classList.contains('flipped');
                cardData.selected = selectedCards.has(card);
                return cardData;
            });

            const jsonString = JSON.stringify(layoutData, null, 2);
            const blob = new Blob([jsonString], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'card_layout.json';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            showFeedback('レイアウトをエクスポートしました！');
        }

        function importLayout(event) {
            const file = event.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const layoutData = JSON.parse(e.target.result);
                    if (!Array.isArray(layoutData)) throw new Error('無効なファイル形式です。');
                    showConfirm('現在のレイアウトをクリアしてインポートしますか？', () => {
                        canvas.innerHTML = '';
                        clearSelection();
                        zIndexCounter = 1;
                        layoutData.forEach(cardData => createCard(cardData));
                        updateStatus(); // ★★★ 更新
                        showFeedback('レイアウトをインポートしました！');
                    });
                } catch (error) {
                    alert('ファイルの読み込みに失敗しました。');
                } finally {
                    importFileInput.value = '';
                }
            };
            reader.readAsText(file);
        }

        function onSelectionUp(e) {
            if (!isSelecting) return;
            isSelecting = false;
            selectionBox.style.display = 'none';
            document.removeEventListener('mousemove', onSelectionMove);
            document.removeEventListener('mouseup', onSelectionUp);

            // ドラッグ量が小さい場合はクリックとみなして選択解除
            const dist = Math.sqrt(Math.pow(selectionEnd.x - selectionStart.x, 2) + Math.pow(selectionEnd.y - selectionStart.y, 2));
            if (dist < 5) {
                // クリック時の挙動（Shiftなしの場合のみ全解除するなど条件分岐可能だが、
                // 元の仕様に合わせてクリック＝全解除とする）
                // ただし、グループ選択モードONの場合は解除しない方がいいかもしれないが、
                // 元の仕様ではクリックで解除だったのでそれに従うか、Shiftキーを見て判断する。
                // ここではシンプルに「Shiftキーなしなら全解除」とする。
                if (!e.shiftKey) {
                    clearSelection();
                }
                return;
            }



             // 矩形選択の確定
            const rectLeft = Math.min(selectionStart.x, selectionEnd.x);
            const rectTop = Math.min(selectionStart.y, selectionEnd.y);
            const rectRight = rectLeft + Math.abs(selectionEnd.x - selectionStart.x);
            const rectBottom = rectTop + Math.abs(selectionEnd.y - selectionStart.y);

            // Shiftキーが押されていない場合は、既存の選択をクリア
            if (!e.shiftKey) {
                clearSelection();
            }

            // 全カードに対して交差判定
            const cards = canvas.querySelectorAll('.card-container');
            let addedCount = 0;
            cards.forEach(card => {
                const cardLeft = parseInt(card.style.left || 0);
                const cardTop = parseInt(card.style.top || 0);
                const cardWidth = card.offsetWidth;
                const cardHeight = card.offsetHeight;
                const cardRight = cardLeft + cardWidth;
                const cardBottom = cardTop + cardHeight;

                // 交差判定 (AABB check)
                const isOverlapping = !(rectRight < cardLeft || 
                                      rectLeft > cardRight || 
                                      rectBottom < cardTop || 
                                      rectTop > cardBottom);

                if (isOverlapping) {
                    if (!selectedCards.has(card)) {
                        selectedCards.add(card);
                        card.classList.add('selected');
                        addedCount++;
                    }
                }
            });
            
            updateStatus();
        }

        function onSelectionMove(e) {
            if (!isSelecting) return;
            e.preventDefault();

            const containerRect = scrollContainer.getBoundingClientRect();
            // ズーム倍率を考慮した座標計算
            const currentX = (e.clientX - containerRect.left + scrollContainer.scrollLeft) / currentZoom;
            const currentY = (e.clientY - containerRect.top + scrollContainer.scrollTop) / currentZoom;
            
            selectionEnd = { x: currentX, y: currentY };

            const left = Math.min(selectionStart.x, selectionEnd.x);
            const top = Math.min(selectionStart.y, selectionEnd.y);
            const width = Math.abs(selectionEnd.x - selectionStart.x);
            const height = Math.abs(selectionEnd.y - selectionStart.y);

            selectionBox.style.left = `${left}px`;
            selectionBox.style.top = `${top}px`;
            selectionBox.style.width = `${width}px`;
            selectionBox.style.height = `${height}px`;
        }

        function handleResizeMove(e) {
            if (!isResizing) return;
            const newWidth = document.body.clientWidth - e.clientX;
            const minWidth = 220;  // 最小幅
            const maxWidth = Math.min(1000, document.body.clientWidth * 0.5);  // 最大幅（画面の半分まで）
            
            if (newWidth >= minWidth && newWidth <= maxWidth) {
                controlPanel.style.width = `${newWidth}px`;
            }
        }

        function handleResizeUp() {
            isResizing = false;
            resizer.classList.remove('resizing');
            document.body.style.cursor = '';
            document.removeEventListener('mousemove', handleResizeMove);
            document.removeEventListener('mouseup', handleResizeUp);
        }

        // ★★★ ズーム機能 ★★★
        function setZoom(value) {
            const oldZoom = currentZoom;
            currentZoom = parseFloat(value);
            
            const viewportCenterX = scrollContainer.scrollLeft + scrollContainer.clientWidth / 2;
            const viewportCenterY = scrollContainer.scrollTop + scrollContainer.clientHeight / 2;
            
            const centerXInCanvas = viewportCenterX / oldZoom;
            const centerYInCanvas = viewportCenterY / oldZoom;
            
            canvas.style.transform = `scale(${currentZoom})`;
            
            const scaledWidth = canvas.offsetWidth * currentZoom;
            const scaledHeight = canvas.offsetHeight * currentZoom;
            scrollWrapper.style.width = `${scaledWidth}px`;
            scrollWrapper.style.height = `${scaledHeight}px`;
            
            scrollContainer.scrollLeft = centerXInCanvas * currentZoom - scrollContainer.clientWidth / 2;
            scrollContainer.scrollTop = centerYInCanvas * currentZoom - scrollContainer.clientHeight / 2;
            
            zoomSlider.value = currentZoom;
            zoomValue.textContent = `${Math.round(currentZoom * 100)}%`;
        }

        async function executeProtocolAction(action, targetCards) {
            switch (action) {
                case 'randomCutHorizon':
                    await execRandomCutHorizon(targetCards);
                    break;
                case 'randomCutVertical':
                    await execRandomCutVertical(targetCards);
                    break;
                case 'pileScrambleCol':
                    await execPileScrambleCol(targetCards);
                    break;
                case 'pileScrambleRow':
                    await execPileScrambleRow(targetCards);
                    break;
                case 'flip':
                    await execFlip(targetCards);
                    break;
                default:
                    console.warn('未知のプロトコル操作:', action);
            }
        }


        function sleep(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        function getActionLabel(action) {
            const map = {
                'randomCutHorizon': 'ランダムカット(横)',
                'randomCutVertical': 'ランダムカット(縦)',
                'pileScrambleCol': 'パイルスクランブル(列)',
                'pileScrambleRow': 'パイルスクランブル(行)',
                'flip': '裏返す/表にする'
            };
            return map[action] || action;
        }

        function updateProtocolListDisplay() {
            protocolList.innerHTML = '';
            if (protocolQueue.length === 0) {
                protocolList.innerHTML = '<p class="text-sm text-gray-400 text-center py-4 empty-msg">手順がありません</p>';
                return;
            }

            protocolQueue.forEach((item, index) => {
                const div = document.createElement('div');
                div.className = 'protocol-item text-sm';
                
                const labelSpan = document.createElement('span');
                labelSpan.textContent = `${getActionLabel(item.action)} × ${item.count}`;
                labelSpan.className = 'font-semibold text-gray-700';
                
                const delBtn = document.createElement('button');
                delBtn.textContent = '×';
                delBtn.className = 'text-red-500 font-bold hover:text-red-700 ml-2 px-2';
                delBtn.onclick = () => {
                    protocolQueue.splice(index, 1);
                    updateProtocolListDisplay();
                };

                div.appendChild(labelSpan);
                div.appendChild(delBtn);
                protocolList.appendChild(div);
            });
        }

        async function runProtocol() {
            if (protocolQueue.length === 0) {
                showFeedback('プロトコルが空です');
                return;
            }

            // ★ 実行開始時の選択カードを固定
            const targetCards = new Set(selectedCards);

            if (targetCards.size === 0) {
                showFeedback('カードが選択されていません');
                return;
            }

            runProtocolBtn.disabled = true;
            runProtocolBtn.textContent = '実行中...';
            addToProtocolBtn.disabled = true;

            const listItems = protocolList.querySelectorAll('.protocol-item');

            try {
                for (let i = 0; i < protocolQueue.length; i++) {
                    const { action, count } = protocolQueue[i];
                    if (listItems[i]) listItems[i].classList.add('executing');

                    for (let c = 0; c < count; c++) {
                        await executeProtocolAction(action, targetCards);
                        await sleep(600);
                    }

                    if (listItems[i]) listItems[i].classList.remove('executing');
                }

                showFeedback('プロトコル実行完了');
            } catch (e) {
                console.error(e);
                showFeedback('実行中にエラーが発生しました');
            } finally {
                runProtocolBtn.disabled = false;
                runProtocolBtn.textContent = '▶ 実行';
                addToProtocolBtn.disabled = false;
            }
        }

        // --- シャッフルロジック (Promiseを返す非同期関数化) ---

        // ランダムカット（横）
        async function execRandomCutHorizon(targetCards) {
            if (targetCards.size < 2) return;
            const cardsArray = Array.from(targetCards);
            
            cardsArray.sort((a, b) => {
                const ay = parseInt(a.style.top || 0);
                const by = parseInt(b.style.top || 0);
                if (Math.abs(ay - by) > GRID_HEIGHT / 2) return ay - by;
                return parseInt(a.style.left || 0) - parseInt(b.style.left || 0);
            });

            const positions = cardsArray.map(card => ({ left: card.style.left, top: card.style.top }));
            const n = cardsArray.length;
            const shift = Math.floor(Math.random() * (n - 1)) + 1;

            cardsArray.forEach((card, index) => {
                const newPosIndex = (index - shift + n) % n;
                card.style.left = positions[newPosIndex].left;
                card.style.top = positions[newPosIndex].top;
                card.style.zIndex = zIndexCounter++;
            });
            incrementShuffleCount();
        }

        // ランダムカット（縦）
        async function execRandomCutVertical(targetCards) {
            if (targetCards.size < 2) return;
            const cardsArray = Array.from(targetCards);
            const columns = new Map();
            cardsArray.forEach(card => {
                const x = parseInt(card.style.left || 0);
                const colKey = Math.round(x / GRID_WIDTH);
                if (!columns.has(colKey)) columns.set(colKey, []);
                columns.get(colKey).push(card);
            });

            columns.forEach(colCards => {
                if (colCards.length < 2) return;
                colCards.sort((a, b) => parseInt(a.style.top || 0) - parseInt(b.style.top || 0));
                const positions = colCards.map(card => ({ left: card.style.left, top: card.style.top }));
                const n = colCards.length;
                const shift = Math.floor(Math.random() * (n - 1)) + 1;
                
                colCards.forEach((card, index) => {
                    const newPosIndex = (index - shift + n) % n;
                    card.style.left = positions[newPosIndex].left;
                    card.style.top = positions[newPosIndex].top;
                    card.style.zIndex = zIndexCounter++;
                });
            });
            incrementShuffleCount();
        }

        // パイルスクランブル（列）
        async function execPileScrambleCol(targetCards) {
            if (targetCards.size === 0) return;
            const cardsArray = Array.from(targetCards);
            const colMap = new Map();
            cardsArray.forEach(card => {
                const x = parseInt(card.style.left || 0);
                const colKey = Math.round(x / GRID_WIDTH);
                if (!colMap.has(colKey)) colMap.set(colKey, []);
                colMap.get(colKey).push(card);
            });

            const colKeys = Array.from(colMap.keys()).sort((a, b) => a - b);
            const n = colKeys.length;
            if (n < 2) return;

            const originalXPositions = colKeys.map(key => colMap.get(key)[0].style.left);
            const indices = Array.from({length: n}, (_, i) => i);
            for (let i = n - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [indices[i], indices[j]] = [indices[j], indices[i]];
            }

            colKeys.forEach((oldKey, originalIndex) => {
                const targetIndex = indices[originalIndex];
                const newX = originalXPositions[targetIndex];
                const cardsInCol = colMap.get(oldKey);
                cardsInCol.forEach(card => {
                    card.style.left = newX;
                    card.style.zIndex = zIndexCounter++;
                });
            });
            incrementShuffleCount();
        }

        // パイルスクランブル（行）
        async function execPileScrambleRow(targetCards) {
            if (targetCards.size === 0) return;
            const cardsArray = Array.from(targetCards);
            const rowMap = new Map();
            cardsArray.forEach(card => {
                const y = parseInt(card.style.top || 0);
                const rowKey = Math.round(y / GRID_HEIGHT);
                if (!rowMap.has(rowKey)) rowMap.set(rowKey, []);
                rowMap.get(rowKey).push(card);
            });

            const rowKeys = Array.from(rowMap.keys()).sort((a, b) => a - b);
            const n = rowKeys.length;
            if (n < 2) return;

            const originalYPositions = rowKeys.map(key => rowMap.get(key)[0].style.top);
            const indices = Array.from({length: n}, (_, i) => i);
            for (let i = n - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [indices[i], indices[j]] = [indices[j], indices[i]];
            }

            rowKeys.forEach((oldKey, originalIndex) => {
                const targetIndex = indices[originalIndex];
                const newY = originalYPositions[targetIndex];
                const cardsInRow = rowMap.get(oldKey);
                cardsInRow.forEach(card => {
                    card.style.top = newY;
                    card.style.zIndex = zIndexCounter++;
                });
            });
            incrementShuffleCount();
        }

        // 裏返す
        async function execFlip(targetCards) {
            targetCards.forEach(card => {
                card.classList.toggle('flipped');
            });
        }

        // DOMContentLoaded内の初期化部分に追加
        function updateScrollContainerSize() {
            const scaledWidth = canvas.offsetWidth * currentZoom;
            const scaledHeight = canvas.offsetHeight * currentZoom;
            scrollWrapper.style.width = `${scaledWidth}px`;
            scrollWrapper.style.height = `${scaledHeight}px`;
        }
        
        // 初期状態更新
        updateStatus();
        updateScrollContainerSize();
    });
</script>

</body>
</html>