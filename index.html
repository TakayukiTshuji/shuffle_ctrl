<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>カード配置アプリ</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            overflow: hidden;
        }
        .grabbing {
            cursor: grabbing;
        }
        .card-container {
            perspective: 1000px;
            -webkit-touch-callout: none; /* iOS Safari */
            touch-action: manipulation;  /* Prevent default touch actions */
            transition: left 0.5s cubic-bezier(0.2, 0.8, 0.2, 1), top 0.5s cubic-bezier(0.2, 0.8, 0.2, 1);
        }
        .card-container.grabbing {
            transition: none;
        }
        .card-inner {
            position: relative;
            width: 100%;
            height: 100%;
            transition: transform 0.6s, box-shadow 0.2s, border 0.2s;
            transform-style: preserve-3d;
            border: 3px solid transparent;
            border-radius: 0.5rem;
        }
        .selected .card-inner {
            border-color: #3b82f6; /* blue-500 */
            box-shadow: 0 0 15px rgba(59, 130, 246, 0.8);
        }
        .card-container.flipped .card-inner {
            transform: rotateY(180deg);
        }
        .card-front, .card-back {
            position: absolute;
            width: 100%;
            height: 100%;
            -webkit-backface-visibility: hidden;
            backface-visibility: hidden;
            border-radius: 0.5rem;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .card-back {
            background-color: #4A90E2;
            color: white;
            transform: rotateY(180deg);
            border: 2px solid white;
        }
        dialog::backdrop {
          background: rgba(0, 0, 0, 0.5);
        }
        #canvas {
            width: 5000px;
            height: 5000px;
            background-size: 120px 170px;
            background-position: -60px -85px;
        }
        .show-grid {
            background-image: 
                linear-gradient(to right, rgba(255, 255, 255, 0.1) 4px, transparent 5px),
                linear-gradient(to bottom, rgba(255, 255, 255, 0.1) 4px, transparent 5px);
        }
        #feedback-msg {
            transition: opacity 0.5s ease-in-out;
        }
        .delete-btn {
            position: absolute;
            top: -10px;
            right: -10px;
            width: 28px;
            height: 28px;
            background-color: #ef4444;
            color: white;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            line-height: 1;
            font-weight: bold;
            cursor: pointer;
            opacity: 0;
            transition: opacity 0.2s, transform 0.2s;
            border: 2px solid white;
            z-index: 10;
            transform: scale(0.8);
        }
        .card-container:hover .delete-btn {
            opacity: 1;
            transform: scale(1);
        }
        .mode-active {
            background-color: #2563eb !important; /* blue-600 */
            box-shadow: inset 0 2px 4px 0 rgba(0, 0, 0, 0.2);
        }
    </style>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&family=Noto+Sans+JP:wght@400;700&display=swap" rel="stylesheet">
</head>
<body class="bg-gray-100">

    <div class="flex h-screen w-screen">
        <!-- 左側のカード配置エリア -->
        <main id="board" class="flex-grow h-full bg-gray-700 relative shadow-inner overflow-auto">
            <div id="canvas" class="relative bg-green-800"></div>
            <div class="absolute top-4 left-4 text-white text-lg bg-black bg-opacity-30 p-2 rounded-lg pointer-events-none" style="z-index: 100;">
                <h1 class="font-bold text-xl">カード配置エリア</h1>
                <p class="text-sm">・ダブルクリック/タップで裏返せます。</p>
                <p class="text-sm">・ドラッグ/スワイプで移動できます。</p>
                <p class="text-sm">・「グループ選択モード」で複数選択できます。</p>
            </div>
        </main>

        <!-- 右側のコントロールパネル -->
        <aside class="w-81 bg-gray-200 p-4 shadow-lg flex flex-col space-y-4 overflow-y-auto">
            <h2 class="text-2xl font-bold text-gray-800 border-b-2 border-gray-400 pb-2">コントロールパネル</h2>
            
            <!-- ★★★ ステータスパネル (枚数・カウンター) ★★★ -->
            <div class="bg-white p-3 rounded-lg shadow space-y-2 text-sm text-gray-700">
                <div class="flex justify-between border-b pb-1">
                    <span>総カード枚数:</span>
                    <span id="total-count" class="font-bold text-lg">0</span>
                </div>
                <div class="flex justify-between border-b pb-1">
                    <span>選択中:</span>
                    <span id="selected-count" class="font-bold text-lg text-blue-600">0</span>
                </div>
                <div class="flex justify-between items-center pt-1">
                    <span>シャッフル回数:</span>
                    <div class="flex items-center space-x-2">
                        <span id="shuffle-count" class="font-bold text-lg text-indigo-600">0</span>
                        <button id="reset-shuffle-count-btn" class="text-xs bg-gray-300 hover:bg-gray-400 px-2 py-1 rounded">リセット</button>
                    </div>
                </div>
            </div>

            <button id="add-card-btn" class="w-full bg-blue-500 hover:bg-blue-600 text-white font-bold py-3 px-4 rounded-lg shadow-md transition-transform transform hover:scale-105">
                カードを追加
            </button>

            <button id="group-select-toggle-btn" class="w-full bg-gray-500 hover:bg-gray-600 text-white font-bold py-2 px-4 rounded-lg shadow-md">
                グループ選択: OFF
            </button>

            <!-- グリッド設定 -->
            <div class="bg-gray-300 p-3 rounded-lg space-y-2">
                <h3 class="font-bold text-gray-700">グリッド設定</h3>
                <label class="flex items-center space-x-2 cursor-pointer">
                    <input type="checkbox" id="snap-to-grid-check" class="form-checkbox h-5 w-5 text-blue-600">
                    <span class="text-gray-780 font-semibold text-xs">マス目にスナップ</span>
                </label>
                <label class="flex items-center space-x-2 cursor-pointer">
                    <input type="checkbox" id="show-grid-check" class="form-checkbox h-5 w-5 text-blue-600">
                    <span class="text-gray-780 font-semibold text-xs">マス目を表示</span>
                </label>
            </div>
            
            <div class="pt-4 border-t border-gray-300 space-y-2">
                <div class="bg-indigo-100 p-2 rounded-lg mb-2">
                    <div class="flex flex-col space-y-2 mb-2">
                        <button id="random-cut-Horizon-btn" class="w-full bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-2 px-4 rounded-lg shadow-md text-sm">
                            ランダムカット(横)
                        </button>
                        <button id="random-cut-Vertical-btn" class="w-full bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-2 px-4 rounded-lg shadow-md text-sm">
                            ランダムカット(縦)
                        </button>
                    </div>
                </div>
                
                 <button id="export-layout-btn" class="w-full bg-green-500 hover:bg-green-600 text-white font-bold py-2 px-4 rounded-lg shadow-md">
                    レイアウトをエクスポート
                </button>
                 <button id="import-layout-btn" class="w-full bg-purple-500 hover:bg-purple-600 text-white font-bold py-2 px-4 rounded-lg shadow-md">
                    レイアウトをインポート
                </button>
                <input type="file" id="import-file-input" class="hidden" accept=".json">
                <p id="feedback-msg" class="text-center text-green-700 font-semibold opacity-0 h-4"></p>
                <button id="delete-selected-btn" class="w-full bg-yellow-500 hover:bg-yellow-600 text-white font-bold py-2 px-4 rounded-lg shadow-md">
                    選択したカードを削除
                </button>
                <button id="clear-layout-btn" class="w-full bg-red-500 hover:bg-red-600 text-white font-bold py-2 px-4 rounded-lg shadow-md">
                    全カードを削除
                </button>
            </div>
        </aside>
    </div>

    <!-- カード追加モーダル -->
    <dialog id="add-card-modal" class="p-8 bg-white rounded-xl shadow-2xl w-full max-w-md">
        <form id="add-card-form">
            <h3 class="text-2xl font-bold mb-6 text-gray-800">新しいカードを作成</h3>
            <fieldset class="mb-4">
                <legend class="font-semibold mb-2 text-gray-700">カードの種類</legend>
                <div class="flex space-x-4">
                    <label class="flex items-center space-x-2"><input type="radio" name="cardType" value="playingCard" checked class="form-radio h-5 w-5 text-blue-600"><span class="text-gray-700">トランプ</span></label>
                    <label class="flex items-center space-x-2"><input type="radio" name="cardType" value="colorCard" class="form-radio h-5 w-5 text-blue-600"><span class="text-gray-700">色カード</span></label>
                </div>
            </fieldset>
            <fieldset id="playing-card-options" class="space-y-4">
                <div>
                    <label for="suit" class="block font-semibold mb-1 text-gray-700">スート (マーク)</label>
                    <select id="suit" name="suit" class="w-full p-2 border border-gray-300 rounded-md focus:ring-2 focus:ring-blue-500 focus:border-blue-500">
                        <option value="♠">スペード (♠)</option><option value="♥">ハート (♥)</option><option value="♦">ダイヤ (♦)</option><option value="♣">クラブ (♣)</option>
                    </select>
                </div>
                <div>
                    <label for="card-count" class="block font-semibold mb-1 text-gray-700">作製枚数</label>
                    <input type="number" id="card-count" name="cardCount" value="1" min="1" class="w-full p-2 border border-gray-300 rounded-md focus:ring-2 focus:ring-blue-500 focus:border-blue-500">
                </div>
            </fieldset>
            <fieldset id="color-card-options" class="hidden">
                <div>
                    <label for="color" class="block font-semibold mb-1 text-gray-700">色を選択</label>
                    <input type="color" id="color" name="color" value="#ff0000" class="w-full h-12 p-1 border border-gray-300 rounded-md cursor-pointer">
                </div>
            </fieldset>
            <div class="mt-8 flex justify-end space-x-4">
                <button type="button" id="cancel-btn" class="px-6 py-2 bg-gray-200 text-gray-800 rounded-md hover:bg-gray-300">キャンセル</button>
                <button type="submit" class="px-6 py-2 bg-green-500 text-white rounded-md hover:bg-green-600 font-semibold">作成</button>
            </div>
        </form>
    </dialog>

    <!-- 確認モーダル -->
    <dialog id="confirm-modal" class="p-6 bg-white rounded-lg shadow-xl w-full max-w-sm">
        <h3 class="text-lg font-bold text-gray-900 mb-4">確認</h3>
        <p id="confirm-message" class="text-gray-700 mb-6">本当に実行しますか？</p>
        <div class="flex justify-end space-x-4">
            <button id="confirm-cancel-btn" class="px-4 py-2 bg-gray-200 text-gray-800 rounded-md hover:bg-gray-300">いいえ</button>
            <button id="confirm-ok-btn" class="px-4 py-2 bg-red-500 text-white rounded-md hover:bg-red-600">はい</button>
        </div>
    </dialog>

<script>
    document.addEventListener('DOMContentLoaded', () => {
        const board = document.getElementById('board');
        const canvas = document.getElementById('canvas');
        const addCardBtn = document.getElementById('add-card-btn');
        const modal = document.getElementById('add-card-modal');
        const addCardForm = document.getElementById('add-card-form');
        const cancelBtn = document.getElementById('cancel-btn');
        const cardTypeRadios = document.querySelectorAll('input[name="cardType"]');
        const playingCardOptions = document.getElementById('playing-card-options');
        const colorCardOptions = document.getElementById('color-card-options');
        const clearLayoutBtn = document.getElementById('clear-layout-btn');
        const feedbackMsg = document.getElementById('feedback-msg');
        const confirmModal = document.getElementById('confirm-modal');
        const confirmMessage = document.getElementById('confirm-message');
        const confirmOkBtn = document.getElementById('confirm-ok-btn');
        const confirmCancelBtn = document.getElementById('confirm-cancel-btn');
        const exportLayoutBtn = document.getElementById('export-layout-btn');
        const importLayoutBtn = document.getElementById('import-layout-btn');
        const importFileInput = document.getElementById('import-file-input');
        const groupSelectToggleBtn = document.getElementById('group-select-toggle-btn');
        const deleteSelectedBtn = document.getElementById('delete-selected-btn');
        const randomCutHorizonBtn = document.getElementById('random-cut-Horizon-btn');
        const randomCutVerticalBtn = document.getElementById('random-cut-Vertical-btn');
        
        const snapToGridCheck = document.getElementById('snap-to-grid-check');
        const showGridCheck = document.getElementById('show-grid-check');

        // ★★★ カウンター要素の取得 ★★★
        const totalCountEl = document.getElementById('total-count');
        const selectedCountEl = document.getElementById('selected-count');
        const shuffleCountEl = document.getElementById('shuffle-count');
        const resetShuffleBtn = document.getElementById('reset-shuffle-count-btn');

        let zIndexCounter = 1;
        let confirmCallback = null;
        const selectedCards = new Set();
        let isGroupSelectMode = false;
        let shuffleCounter = 0; // シャッフル回数
        
        const GRID_WIDTH = 120;
        const GRID_HEIGHT = 170;

        board.scrollTop = (canvas.scrollHeight - board.clientHeight) / 2;
        board.scrollLeft = (canvas.scrollWidth - board.clientWidth) / 2;
        
        // --- イベントリスナー ---
        addCardBtn.addEventListener('click', () => modal.showModal());
        cancelBtn.addEventListener('click', () => modal.close());
        modal.addEventListener('click', (e) => { if (e.target === modal) modal.close(); });

        cardTypeRadios.forEach(radio => {
            radio.addEventListener('change', (e) => {
                playingCardOptions.classList.toggle('hidden', e.target.value !== 'playingCard');
                colorCardOptions.classList.toggle('hidden', e.target.value !== 'colorCard');
            });
        });
        
        showGridCheck.addEventListener('change', (e) => {
            canvas.classList.toggle('show-grid', e.target.checked);
        });

        // ★★★ シャッフル回数リセット ★★★
        resetShuffleBtn.addEventListener('click', () => {
            shuffleCounter = 0;
            updateStatus();
        });

        addCardForm.addEventListener('submit', (e) => {
            e.preventDefault();
            const formData = new FormData(addCardForm);
            const cardData = Object.fromEntries(formData.entries());
            const count = parseInt(cardData.cardCount) || 1;

            for (let i = 0; i < count; i++) {
                const singleCardData = { ...cardData };
                const offsetX = (i % 5) * 20 - 40;
                const offsetY = Math.floor(i / 5) * 20 - 20;

                let left = board.scrollLeft + (board.clientWidth / 2) - 56 + offsetX;
                let top = board.scrollTop + (board.clientHeight / 2) - 80 + offsetY;
                
                if (snapToGridCheck.checked) {
                    left = Math.round(left / GRID_WIDTH) * GRID_WIDTH;
                    top = Math.round(top / GRID_HEIGHT) * GRID_HEIGHT;
                }

                singleCardData.left = `${left}px`;
                singleCardData.top = `${top}px`;
                singleCardData.zIndex = zIndexCounter++;
                createCard(singleCardData);
            }
            
            updateStatus(); // ★★★ 更新
            modal.close();
            addCardForm.reset();
            document.getElementById('card-count').value = '1';
            playingCardOptions.classList.remove('hidden');
            colorCardOptions.classList.add('hidden');
        });

        clearLayoutBtn.addEventListener('click', () => {
             showConfirm('本当にすべてのカードを削除しますか？', () => {
                canvas.innerHTML = '';
                zIndexCounter = 1;
                clearSelection();
                updateStatus(); // ★★★ 更新
            });
        });

        deleteSelectedBtn.addEventListener('click', () => {
            if (selectedCards.size === 0) {
                showFeedback('削除するカードが選択されていません。');
                return;
            }

            showConfirm(`選択した${selectedCards.size}枚のカードを本当に削除しますか？`, () => {
                selectedCards.forEach(card => {
                    card.remove();
                });
                clearSelection();
                showFeedback('選択したカードを削除しました。');
                updateStatus(); // ★★★ 更新
            });
        });

        randomCutHorizonBtn.addEventListener('click', () => {
            if (selectedCards.size < 2) {
                showFeedback('ランダムカットするには2枚以上選択してください。');
                return;
            }

            const cardsArray = Array.from(selectedCards);

            // 座標に基づいてソート（左上から右下へ）
            cardsArray.sort((a, b) => {
                const ay = parseInt(a.style.top || 0);
                const by = parseInt(b.style.top || 0);
                // 多少のズレは同じ行とみなす
                if (Math.abs(ay - by) > GRID_HEIGHT / 2) {
                    return ay - by;
                }
                const ax = parseInt(a.style.left || 0);
                const bx = parseInt(b.style.left || 0);
                return ax - bx;
            });

            // 各カードの位置を記録
            const positions = cardsArray.map(card => ({
                left: card.style.left,
                top: card.style.top
            }));

            const n = cardsArray.length;
            
            // ★★★ 修正: 1枚だけ右に移動（右シフト量1固定） ★★★
            const shift = 1;

            // 各カードを新しい位置に移動（右シフト）
            cardsArray.forEach((card, index) => {
                // 右シフト: index のカードを (index + shift) % n の位置へ
                const newPosIndex = (index + shift) % n;
                
                card.style.left = positions[newPosIndex].left;
                card.style.top = positions[newPosIndex].top;
                card.style.zIndex = zIndexCounter++;
            });

            showFeedback('1枚右に移動しました');
        });

        randomCutVerticalBtn.addEventListener('click', () => {
            if (selectedCards.size < 2) {
                showFeedback('ランダムカットするには2枚以上選択してください。');
                return;
            }

            const cardsArray = Array.from(selectedCards);

            // 縦方向: 同じ列（X座標が近い）のカードをグループ化
            const columns = new Map();
            cardsArray.forEach(card => {
                const x = parseInt(card.style.left || 0);
                const colKey = Math.round(x / GRID_WIDTH);
                if (!columns.has(colKey)) {
                    columns.set(colKey, []);
                }
                columns.get(colKey).push(card);
            });

            // 各列ごとに縦方向カット（1枚下移動）
            columns.forEach(colCards => {
                if (colCards.length < 2) return;
                
                // Y座標でソート
                colCards.sort((a, b) => {
                    return parseInt(a.style.top || 0) - parseInt(b.style.top || 0);
                });

                const positions = colCards.map(card => ({
                    left: card.style.left,
                    top: card.style.top
                }));

                const n = colCards.length;
                const shift = 1; // 1枚下移動

                colCards.forEach((card, index) => {
                    const newPosIndex = (index + shift) % n;
                    card.style.left = positions[newPosIndex].left;
                    card.style.top = positions[newPosIndex].top;
                    card.style.zIndex = zIndexCounter++;
                });
            });

            showFeedback('縦方向に1枚下移動しました');
        });


        confirmOkBtn.addEventListener('click', () => {
            if (confirmCallback) confirmCallback();
            confirmModal.close();
        });
        confirmCancelBtn.addEventListener('click', () => confirmModal.close());

        exportLayoutBtn.addEventListener('click', exportLayout);
        importLayoutBtn.addEventListener('click', () => importFileInput.click());
        importFileInput.addEventListener('change', importLayout);
        
        board.addEventListener('mousedown', (e) => {
            if (!isGroupSelectMode && (e.target === board || e.target === canvas)) {
                clearSelection();
            }
        });

        groupSelectToggleBtn.addEventListener('click', () => {
            isGroupSelectMode = !isGroupSelectMode;
            groupSelectToggleBtn.classList.toggle('mode-active', isGroupSelectMode);
            groupSelectToggleBtn.textContent = `グループ選択: ${isGroupSelectMode ? 'ON' : 'OFF'}`;
            if (!isGroupSelectMode) {
                clearSelection();
            }
        });


        // --- 関数定義 ---
        
        // ★★★ ステータス更新関数 ★★★
        function updateStatus() {
            const cards = canvas.querySelectorAll('.card-container');
            totalCountEl.textContent = cards.length;
            selectedCountEl.textContent = selectedCards.size;
            shuffleCountEl.textContent = shuffleCounter;
        }

        // ★★★ シャッフル回数インクリメント ★★★
        function incrementShuffleCount() {
            shuffleCounter++;
            updateStatus();
        }

        function showConfirm(message, onConfirm) {
            confirmMessage.textContent = message;
            confirmCallback = onConfirm;
            confirmModal.showModal();
        }
        
        function showFeedback(message) {
            feedbackMsg.textContent = message;
            feedbackMsg.style.opacity = 1;
            setTimeout(() => { feedbackMsg.style.opacity = 0; }, 2500);
        }

        function clearSelection() {
            selectedCards.forEach(card => card.classList.remove('selected'));
            selectedCards.clear();
            updateStatus(); // ★★★ 更新
        }

        function toggleSelection(card) {
            if (selectedCards.has(card)) {
                selectedCards.delete(card);
                card.classList.remove('selected');
            } else {
                selectedCards.add(card);
                card.classList.add('selected');
            }
            updateStatus(); // ★★★ 更新
        }

        function createCard(data) {
            const cardContainer = document.createElement('div');
            cardContainer.className = 'card-container absolute w-28 h-40 cursor-grab select-none';
            cardContainer.style.left = data.left;
            cardContainer.style.top = data.top;
            cardContainer.style.zIndex = data.zIndex;
            cardContainer.dataset.cardType = data.cardType;

            const cardInner = document.createElement('div');
            cardInner.className = 'card-inner';

            const cardFront = document.createElement('div');
            cardFront.className = 'card-front bg-white shadow-lg border-2 border-gray-300';
            
            const cardBack = document.createElement('div');
            cardBack.className = 'card-back text-5xl font-bold';
            cardBack.textContent = '?';

            if (data.cardType === 'playingCard') {
                const { suit } = data;
                cardContainer.dataset.suit = suit;
                const color = (suit === '♥' || suit === '♦') ? 'text-red-600' : 'text-black';
                cardFront.innerHTML = `<div class="w-full h-full flex items-center justify-center text-7xl font-bold ${color}">${suit}</div>`;
            } else {
                cardContainer.dataset.color = data.color;
                cardFront.style.backgroundColor = data.color;
                cardFront.style.border = '2px solid rgba(0,0,0,0.2)';
            }
            
            if (data.flipped) cardContainer.classList.add('flipped');
            if (data.selected) toggleSelection(cardContainer); // ここでupdateStatusが呼ばれるが、ループ中のため負荷が気になる場合は調整
            
            cardInner.appendChild(cardFront);
            cardInner.appendChild(cardBack);
            cardContainer.appendChild(cardInner);

            const deleteBtn = document.createElement('div');
            deleteBtn.className = 'delete-btn';
            deleteBtn.innerHTML = '&times;';
            deleteBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                showConfirm('このカードを削除しますか？', () => {
                    cardContainer.remove();
                    if(selectedCards.has(cardContainer)) {
                        selectedCards.delete(cardContainer);
                    }
                    updateStatus(); // ★★★ 更新
                });
            });
            cardContainer.appendChild(deleteBtn);
            canvas.appendChild(cardContainer);

            makeDraggable(cardContainer);
            
            cardContainer.addEventListener('dblclick', () => cardContainer.classList.toggle('flipped'));
            let lastTap = 0;
            cardContainer.addEventListener('touchend', () => {
                if (cardContainer.didMove) return;
                const currentTime = new Date().getTime();
                if (currentTime - lastTap < 300) {
                    cardContainer.classList.toggle('flipped');
                }
                lastTap = currentTime;
            });
            
            cardContainer.addEventListener('contextmenu', e => e.preventDefault());
            
            if (parseInt(data.zIndex) >= zIndexCounter) {
                zIndexCounter = parseInt(data.zIndex) + 1;
            }
        }
        
        function makeDraggable(element) {
            let initialPositions = new Map();
            let dragStartPos = null;
            let didMove = false;

            function onPointerDown(e) {
                if (e.target.classList.contains('delete-btn')) return;
                const isTouchEvent = e.type === 'touchstart';
                if (!isTouchEvent) e.preventDefault();

                element.didMove = false;
                didMove = false;
                const startX = isTouchEvent ? e.touches[0].clientX : e.clientX;
                const startY = isTouchEvent ? e.touches[0].clientY : e.clientY;
                dragStartPos = { x: startX, y: startY };

                document.addEventListener(isTouchEvent ? 'touchmove' : 'mousemove', onPointerMove, { passive: false });
                document.addEventListener(isTouchEvent ? 'touchend' : 'mouseup', onPointerUp);
            }

            function onPointerMove(e) {
                if (dragStartPos === null) return;
                const isTouchEvent = e.type === 'touchmove';
                if (isTouchEvent) e.preventDefault();

                const moveX = isTouchEvent ? e.touches[0].clientX : e.clientX;
                const moveY = isTouchEvent ? e.touches[0].clientY : e.clientY;

                if (!didMove && (Math.abs(moveX - dragStartPos.x) > 5 || Math.abs(moveY - dragStartPos.y) > 5)) {
                    didMove = true;
                    element.didMove = true;
                    
                    if (!selectedCards.has(element)) {
                        if (!isGroupSelectMode) {
                            clearSelection();
                        }
                        selectedCards.add(element);
                        element.classList.add('selected');
                        updateStatus(); // ★★★ 更新
                    }

                    initialPositions.clear();
                    selectedCards.forEach(card => {
                        card.classList.add('grabbing');
                        card.style.zIndex = zIndexCounter++;
                        initialPositions.set(card, { left: card.offsetLeft, top: card.offsetTop });
                    });
                }

                if (didMove) {
                    const deltaX = moveX - dragStartPos.x;
                    const deltaY = moveY - dragStartPos.y;
                    selectedCards.forEach(card => {
                        const initialPos = initialPositions.get(card);
                        if (initialPos) {
                            let x = initialPos.left + deltaX;
                            let y = initialPos.top + deltaY;
                            
                            x = Math.max(0, Math.min(x, canvas.clientWidth - card.offsetWidth));
                            y = Math.max(0, Math.min(y, canvas.clientHeight - card.offsetHeight));
                            
                            card.style.left = `${x}px`;
                            card.style.top = `${y}px`;
                        }
                    });
                }
            }

            function onPointerUp(e) {
                if (!didMove) {
                    const isTouchEvent = e.type.startsWith('touch');
                    if (isGroupSelectMode) {
                        toggleSelection(element);
                    } else {
                        if (isTouchEvent || !e.shiftKey) {
                            clearSelection();
                        }
                        toggleSelection(element);
                    }
                } else {
                    if (snapToGridCheck.checked) {
                        selectedCards.forEach(card => {
                            let currentLeft = parseInt(card.style.left || 0);
                            let currentTop = parseInt(card.style.top || 0);

                            let snapLeft = Math.round(currentLeft / GRID_WIDTH) * GRID_WIDTH;
                            let snapTop = Math.round(currentTop / GRID_HEIGHT) * GRID_HEIGHT;

                            snapLeft = Math.max(0, Math.min(snapLeft, canvas.clientWidth - card.offsetWidth));
                            snapTop = Math.max(0, Math.min(snapTop, canvas.clientHeight - card.offsetHeight));

                            card.style.left = `${snapLeft}px`;
                            card.style.top = `${snapTop}px`;
                        });
                    }
                }

                selectedCards.forEach(card => card.classList.remove('grabbing'));
                dragStartPos = null;
                initialPositions.clear();
                
                const isTouchEvent = e.type === 'touchend';
                document.removeEventListener(isTouchEvent ? 'touchmove' : 'mousemove', onPointerMove);
                document.removeEventListener(isTouchEvent ? 'touchend' : 'mouseup', onPointerUp);
            }

            element.addEventListener('mousedown', onPointerDown);
            element.addEventListener('touchstart', onPointerDown, { passive: false });
        }

        function exportLayout() {
            const cards = Array.from(canvas.querySelectorAll('.card-container'));
            if (cards.length === 0) {
                showFeedback('エクスポートするカードがありません。');
                return;
            }
            const layoutData = cards.map(card => {
                const cardData = { ...card.dataset };
                cardData.left = card.style.left;
                cardData.top = card.style.top;
                cardData.zIndex = card.style.zIndex;
                cardData.flipped = card.classList.contains('flipped');
                cardData.selected = selectedCards.has(card);
                return cardData;
            });

            const jsonString = JSON.stringify(layoutData, null, 2);
            const blob = new Blob([jsonString], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'card_layout.json';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            showFeedback('レイアウトをエクスポートしました！');
        }

        function importLayout(event) {
            const file = event.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const layoutData = JSON.parse(e.target.result);
                    if (!Array.isArray(layoutData)) throw new Error('無効なファイル形式です。');
                    showConfirm('現在のレイアウトをクリアしてインポートしますか？', () => {
                        canvas.innerHTML = '';
                        clearSelection();
                        zIndexCounter = 1;
                        layoutData.forEach(cardData => createCard(cardData));
                        updateStatus(); // ★★★ 更新
                        showFeedback('レイアウトをインポートしました！');
                    });
                } catch (error) {
                    alert('ファイルの読み込みに失敗しました。');
                } finally {
                    importFileInput.value = '';
                }
            };
            reader.readAsText(file);
        }
        
        // 初期状態更新
        updateStatus();
    });
</script>

</body>
</html>
```
```eof