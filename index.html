<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ã‚«ãƒ¼ãƒ‰é…ç½®ã‚¢ãƒ—ãƒª</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            overflow: hidden;
        }
        .grabbing {
            cursor: grabbing;
        }
        .card-container {
            perspective: 1000px;
            -webkit-touch-callout: none; /* iOS Safari */
            touch-action: manipulation;  /* Prevent default touch actions */
            transition: left 0.5s cubic-bezier(0.2, 0.8, 0.2, 1), top 0.5s cubic-bezier(0.2, 0.8, 0.2, 1);
        }
        .card-container.grabbing {
            transition: none;
        }
        .card-inner {
            position: relative;
            width: 100%;
            height: 100%;
            transition: transform 0.6s, box-shadow 0.2s, border 0.2s;
            transform-style: preserve-3d;
            border: 3px solid transparent;
            border-radius: 0.5rem;
        }
        .selected .card-inner {
            border-color: #3b82f6; /* blue-500 */
            box-shadow: 0 0 15px rgba(59, 130, 246, 0.8);
        }
        .card-container.flipped .card-inner {
            transform: rotateY(180deg);
        }
        .card-front, .card-back {
            position: absolute;
            width: 100%;
            height: 100%;
            -webkit-backface-visibility: hidden;
            backface-visibility: hidden;
            border-radius: 0.5rem;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .card-back {
            background-color: #4A90E2;
            color: white;
            transform: rotateY(180deg);
            border: 2px solid white;
        }
        dialog::backdrop {
          background: rgba(0, 0, 0, 0.5);
        }
        #canvas {
            width: 10000px; 
            height: 10000px; 
            background-size: 120px 170px; 
            background-position: -60px -85px; 
            transform-origin: 0 0; 
            will-change: transform;
        }
        .show-grid {
            background-image: 
                linear-gradient(to right, rgba(255, 255, 255, 0.1) 4px, transparent 5px),
                linear-gradient(to bottom, rgba(255, 255, 255, 0.1) 4px, transparent 5px);
        }
        #feedback-msg {
            transition: opacity 0.5s ease-in-out;
        }
        .delete-btn {
            position: absolute;
            top: -10px;
            right: -10px;
            width: 28px;
            height: 28px;
            background-color: #ef4444;
            color: white;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            line-height: 1;
            font-weight: bold;
            cursor: pointer;
            opacity: 0;
            transition: opacity 0.2s, transform 0.2s;
            border: 2px solid white;
            z-index: 10;
            transform: scale(0.8);
        }
        .card-container:hover .delete-btn {
            opacity: 1;
            transform: scale(1);
        }
        .mode-active {
            background-color: #2563eb !important; /* blue-600 */
            box-shadow: inset 0 2px 4px 0 rgba(0, 0, 0, 0.2);
        }
        #selection-box {
            position: absolute;
            border: 2px dashed #3b82f6;
            background-color: rgba(59, 130, 246, 0.2);
            pointer-events: none;
            z-index: 9999;
            display: none;
        }
        #resizer {
            width: 8px;
            background-color: #cbd5e1;
            cursor: col-resize;
            transition: background-color 0.2s;
            flex-shrink: 0;
            z-index: 50;
        }

        #resizer:hover, #resizer.resizing {
            background-color: #3b82f6;
        }
        #board {
            overflow: hidden; /* autoã‹ã‚‰å¤‰æ›´ */
        }
        .protocol-item {
            background-color: #fff;
            border: 1px solid #e2e8f0;
            border-radius: 0.375rem;
            padding: 0.5rem;
            margin-bottom: 0.5rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-shadow: 0 1px 2px 0 rgba(0, 0, 0, 0.05);
        }
        .protocol-item:before {
            content: "â–¼";
            color: #94a3b8;
            font-size: 0.7rem;
            margin-right: 0.5rem;
        }
        .executing {
            border-color: #3b82f6;
            background-color: #eff6ff;
            box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.5);
        }
        #scroll-wrapper {
            position: relative;
            transform-origin: 0 0;
        }
        /* ãƒ©ãƒ™ãƒ«ãƒãƒƒã‚¸ */
        .card-label-badge {
            position: absolute;
            bottom: -8px;
            left: 50%;
            transform: translateX(-50%);
            background-color: #f59e0b;
            color: white;
            font-size: 10px;
            font-weight: bold;
            padding: 1px 6px;
            border-radius: 999px;
            border: 1.5px solid white;
            z-index: 20;
            pointer-events: none;
            white-space: nowrap;
        }
        .card-label-badges {
            position: absolute;
            bottom: -10px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            flex-wrap: nowrap;
            gap: 2px;
            z-index: 20;
            pointer-events: none;
            white-space: nowrap;
        }
        #control-panel button {
            font-size: 1.2rem; /* ãŠå¥½ã¿ã§ 1.1rem ã‚„ 1.125rem ã«èª¿æ•´å¯ */
        }
    </style>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&family=Noto+Sans+JP:wght@400;700&display=swap" rel="stylesheet">
</head>
<body class="bg-gray-100">
    <div class="flex h-screen w-screen">
        <!-- å·¦å´ã®ã‚«ãƒ¼ãƒ‰é…ç½®ã‚¨ãƒªã‚¢ -->
        <main id="board" class="flex-grow h-full bg-gray-700 relative shadow-inner overflow-hidden">
            <div id="scroll-container" style="width: 100%; height: 100%; overflow: auto; position: relative;">
                <div id="scroll-wrapper" style="position: relative; transform-origin: 0 0;">
                    <div id="canvas" class="relative bg-green-800">
                        <div id="selection-box"></div>
                    </div>
                </div>
                <div class="absolute top-4 left-4 text-white text-lg bg-black bg-opacity-30 p-2 rounded-lg pointer-events-none" style="z-index: 100;">
                    <h1 class="font-bold text-xl">ã‚«ãƒ¼ãƒ‰é…ç½®ã‚¨ãƒªã‚¢</h1>
                    <p class="text-sm">ãƒ»ãƒ€ãƒ–ãƒ«ã‚¯ãƒªãƒƒã‚¯/ã‚¿ãƒƒãƒ—ã§è£è¿”ã›ã¾ã™ã€‚</p>
                    <p class="text-sm">ãƒ»ãƒ‰ãƒ©ãƒƒã‚°/ã‚¹ãƒ¯ã‚¤ãƒ—ã§ç§»å‹•ã§ãã¾ã™ã€‚</p>
                    <p class="text-sm">ãƒ»ã€Œã‚°ãƒ«ãƒ¼ãƒ—é¸æŠãƒ¢ãƒ¼ãƒ‰ã€ã§è¤‡æ•°é¸æŠã§ãã¾ã™ã€‚</p>
                </div>
            </div>
        </main>

        <!-- ãƒªã‚µã‚¤ã‚¶ãƒ¼è¦ç´  -->
        <div id="resizer" title="ãƒ‰ãƒ©ãƒƒã‚°ã—ã¦ãƒ‘ãƒãƒ«å¹…ã‚’èª¿æ•´"></div>

        <!-- å³å´ã®ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«ãƒ‘ãƒãƒ« -->
        <aside id="control-panel" class="flex-none bg-gray-200 p-4 shadow-lg flex flex-col space-y-4 overflow-y-auto" style="width: 400px; min-width: 220px; max-width: 1000px;">
            <h2 class="text-2xl font-bold text-gray-800 border-b-2 border-gray-400 pb-2">ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«ãƒ‘ãƒãƒ«</h2>
            
            <!-- â˜…â˜…â˜… ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ãƒ‘ãƒãƒ« (æšæ•°ãƒ»ã‚«ã‚¦ãƒ³ã‚¿ãƒ¼) â˜…â˜…â˜… -->
            <div class="bg-white p-3 rounded-lg shadow space-y-2 text-sm text-gray-700">
                <div class="flex justify-between border-b pb-1">
                    <span>ç·ã‚«ãƒ¼ãƒ‰æšæ•°:</span>
                    <span id="total-count" class="font-bold text-lg">0</span>
                </div>
                <div class="flex justify-between border-b pb-1">
                    <span>é¸æŠä¸­:</span>
                    <span id="selected-count" class="font-bold text-lg text-blue-600">0</span>
                </div>
                <div class="flex justify-between items-center pt-1">
                    <span>ã‚·ãƒ£ãƒƒãƒ•ãƒ«å›æ•°:</span>
                    <div class="flex items-center space-x-2">
                        <span id="shuffle-count" class="font-bold text-lg text-indigo-600">0</span>
                        <button id="reset-shuffle-count-btn" class="text-xs bg-gray-300 hover:bg-gray-400 px-2 py-1 rounded">ãƒªã‚»ãƒƒãƒˆ</button>
                    </div>
                </div>
            </div>

            <div class="bg-gray-300 p-3 rounded-lg space-y-2">
                <h3 class="font-bold text-gray-700">è¡¨ç¤ºè¨­å®š</h3>
                <div class="flex items-center space-x-2">
                    <span class="text-xs font-bold text-gray-600">ã‚ºãƒ¼ãƒ :</span>
                    <input type="range" id="zoom-slider" min="0.3" max="2.0" step="0.1" value="1.0" class="w-full cursor-pointer">
                    <span id="zoom-value" class="text-xs font-bold w-10 text-right">100%</span>
                </div>
                <div class="flex items-center space-x-2">
                    <button id="zoom-reset-btn" class="text-xs bg-white hover:bg-gray-100 px-2 py-1 rounded shadow w-full">100%ã«æˆ»ã™</button>
                </div>
            </div>

            <!-- ãƒ—ãƒ­ãƒˆã‚³ãƒ«ä½œæˆUI -->
            <div class="bg-orange-100 p-4 rounded-lg space-y-3 border border-orange-200 mb-6">
                <h3 class="font-bold text-orange-800 text-lg">ãƒ—ãƒ­ãƒˆã‚³ãƒ«ä½œæˆ (ä¸€é€£ã®æµã‚Œ)</h3>
                <div class="flex space-x-2">
                    <select id="protocol-action-select" class="flex-1 p-2 border border-orange-300 rounded text-sm bg-white">
                        <option value="randomCutHorizon">ãƒ©ãƒ³ãƒ€ãƒ ã‚«ãƒƒãƒˆ(æ¨ª)</option>
                        <option value="randomCutVertical">ãƒ©ãƒ³ãƒ€ãƒ ã‚«ãƒƒãƒˆ(ç¸¦)</option>
                        <option value="pileScrambleCol">ãƒ‘ã‚¤ãƒ«ã‚¹ã‚¯ãƒ©ãƒ³ãƒ–ãƒ«(åˆ—)</option>
                        <option value="pileScrambleRow">ãƒ‘ã‚¤ãƒ«ã‚¹ã‚¯ãƒ©ãƒ³ãƒ–ãƒ«(è¡Œ)</option>
                        <option value="flip">è£è¿”ã™/è¡¨ã«ã™ã‚‹</option>
                    </select>
                    <input type="number" id="protocol-action-count" value="1" min="1" 
                        class="w-20 p-2 border border-orange-300 rounded text-sm text-center" 
                        title="å›æ•°">
                </div>
                <button id="add-to-protocol-btn" 
                        class="w-full bg-orange-500 hover:bg-orange-600 text-white font-bold py-2 px-3 rounded shadow">
                    ï¼‹ æ‰‹é †ã«è¿½åŠ 
                </button>
                
                <!-- ãƒ—ãƒ­ãƒˆã‚³ãƒ«ãƒªã‚¹ãƒˆ -->
                <div id="protocol-list" 
                    class="bg-gray-50 p-3 rounded border border-gray-300 min-h-[150px] max-h-[300px] overflow-y-auto">
                    <p class="text-sm text-gray-400 text-center py-4 empty-msg">æ‰‹é †ãŒã‚ã‚Šã¾ã›ã‚“</p>
                </div>

                <div class="flex space-x-2">
                    <button id="run-protocol-btn" 
                            class="flex-1 bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-3 rounded shadow">
                        â–¶ å®Ÿè¡Œ
                    </button>
                    <button id="clear-protocol-btn" 
                            class="flex-1 bg-gray-400 hover:bg-gray-500 text-white font-bold py-2 px-3 rounded shadow">
                        ã‚¯ãƒªã‚¢
                    </button>
                </div>
            </div>

            <div class="bg-teal-100 p-3 rounded-lg space-y-2">
                <h3 class="font-bold text-teal-800 text-sm">ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆã‹ã‚‰è¿½åŠ </h3>
                <select id="template-select" class="w-full p-2 border border-teal-300 rounded text-sm bg-white">
                    <option value="adj_graph_g">éš£æ¥ã‚³ãƒŸãƒƒãƒˆãƒ¡ãƒ³ãƒˆ (ã‚°ãƒ©ãƒ•G)</option>
                </select>
                <button id="apply-template-btn" class="w-full bg-teal-600 hover:bg-teal-700 text-white font-bold py-2 px-4 rounded shadow text-sm">
                    é…ç½®
                </button>
            </div>

            <!-- ãƒ©ãƒ™ãƒ«ç®¡ç† -->
            <div class="bg-yellow-50 p-3 rounded-lg space-y-2 border border-yellow-200">
                <h3 class="font-bold text-yellow-800 text-sm">ğŸ· ã‚«ãƒ¼ãƒ‰ãƒ©ãƒ™ãƒ«ç®¡ç†</h3>
                <div class="flex space-x-2">
                    <input type="text" id="label-input" placeholder="ãƒ©ãƒ™ãƒ«å (ä¾‹: A)" maxlength="6"
                        class="flex-1 p-2 border border-yellow-300 rounded text-sm bg-white">
                    <button id="assign-label-btn"
                        class="bg-yellow-500 hover:bg-yellow-600 text-white font-bold py-1 px-3 rounded text-sm">ä»˜ä¸</button>
                    <button id="remove-label-btn"
                        class="bg-gray-400 hover:bg-gray-500 text-white font-bold py-1 px-3 rounded text-sm">å‰Šé™¤</button>
                </div>
                <p class="text-xs text-gray-500">é¸æŠã‚«ãƒ¼ãƒ‰ã«ãƒ©ãƒ™ãƒ«ã‚’ä»˜ä¸/å‰Šé™¤ã—ã¾ã™ã€‚</p>

                <div class="border-t border-yellow-200 pt-2 space-y-1">
                    <h4 class="text-xs font-bold text-yellow-700">ãƒ©ãƒ™ãƒ«åˆ¥ã‚·ãƒ£ãƒƒãƒ•ãƒ«</h4>
                    <select id="label-shuffle-target" class="w-full p-1 border border-yellow-300 rounded text-sm bg-white">
                        <option value="__all__">å…¨ãƒ©ãƒ™ãƒ«ï¼ˆãã‚Œãã‚Œç‹¬ç«‹ï¼‰</option>
                    </select>
                    <div class="flex space-x-2">
                        <button id="label-pile-col-btn"
                            class="flex-1 bg-pink-500 hover:bg-pink-600 text-white font-bold py-1 px-2 rounded text-xs">
                            åˆ—ã‚¹ã‚¯ãƒ©ãƒ³ãƒ–ãƒ«
                        </button>
                        <button id="label-pile-row-btn"
                            class="flex-1 bg-pink-500 hover:bg-pink-600 text-white font-bold py-1 px-2 rounded text-xs">
                            è¡Œã‚¹ã‚¯ãƒ©ãƒ³ãƒ–ãƒ«
                        </button>
                    </div>
                    <div class="flex space-x-2">
                        <button id="label-cut-h-btn"
                            class="flex-1 bg-indigo-500 hover:bg-indigo-600 text-white font-bold py-1 px-2 rounded text-xs">
                            æ¨ªã‚«ãƒƒãƒˆ
                        </button>
                        <button id="label-cut-v-btn"
                            class="flex-1 bg-indigo-500 hover:bg-indigo-600 text-white font-bold py-1 px-2 rounded text-xs">
                            ç¸¦ã‚«ãƒƒãƒˆ
                        </button>
                    </div>
                </div>
            </div>

            <button id="add-card-btn" class="w-full bg-blue-500 hover:bg-blue-600 text-white font-bold py-3 px-4 rounded-lg shadow-md transition-transform transform hover:scale-105">
                ã‚«ãƒ¼ãƒ‰ã‚’è¿½åŠ 
            </button>

            <button id="group-select-toggle-btn" class="w-full bg-gray-500 hover:bg-gray-600 text-white font-bold py-2 px-4 rounded-lg shadow-md">
                ã‚°ãƒ«ãƒ¼ãƒ—é¸æŠ: OFF
            </button>

            <!-- ã‚°ãƒªãƒƒãƒ‰è¨­å®š -->
            <div class="bg-gray-300 p-3 rounded-lg space-y-2">
                <h3 class="font-bold text-gray-700">ã‚°ãƒªãƒƒãƒ‰è¨­å®š</h3>
                <label class="flex items-center space-x-2 cursor-pointer">
                    <input type="checkbox" id="snap-to-grid-check" class="form-checkbox h-5 w-5 text-blue-600">
                    <span class="text-gray-780 font-semibold text-xs">ãƒã‚¹ç›®ã«ã‚¹ãƒŠãƒƒãƒ—</span>
                </label>
                <label class="flex items-center space-x-2 cursor-pointer">
                    <input type="checkbox" id="show-grid-check" class="form-checkbox h-5 w-5 text-blue-600">
                    <span class="text-gray-780 font-semibold text-xs">ãƒã‚¹ç›®ã‚’è¡¨ç¤º</span>
                </label>
            </div>
            
            <div class="pt-4 border-t border-gray-300 space-y-2">
                <div class="bg-indigo-100 p-2 rounded-lg mb-2">
                    <div class="flex flex-col space-y-2 mb-2">
                        <button id="random-cut-Horizon-btn" class="w-full bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-2 px-4 rounded-lg shadow-md text-sm">
                            ãƒ©ãƒ³ãƒ€ãƒ ã‚«ãƒƒãƒˆ(æ¨ª)
                        </button>
                        <button id="random-cut-Vertical-btn" class="w-full bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-2 px-4 rounded-lg shadow-md text-sm">
                            ãƒ©ãƒ³ãƒ€ãƒ ã‚«ãƒƒãƒˆ(ç¸¦)
                        </button>
                    </div>
                </div>

                <div class="bg-pink-100 p-2 rounded-lg mb-2">
                    <h3 class="text-xs font-bold text-pink-800 mb-1 ml-1">æŸã‚·ãƒ£ãƒƒãƒ•ãƒ« (Scramble)</h3>
                    <div class="flex flex-col space-y-2 mb-2">
                        <button id="pile-scramble-col-btn" class="w-full bg-pink-600 hover:bg-pink-700 text-white font-bold py-2 px-4 rounded-lg shadow-md text-sm">
                            å‚ç›´ãƒ‘ã‚¤ãƒ«ã‚¹ã‚¯ãƒ©ãƒ³ãƒ–ãƒ«
                        </button>
                        <button id="pile-scramble-row-btn" class="w-full bg-pink-600 hover:bg-pink-700 text-white font-bold py-2 px-4 rounded-lg shadow-md text-sm">
                            æ°´å¹³ãƒ‘ã‚¤ãƒ«ã‚¹ã‚¯ãƒ©ãƒ³ãƒ–ãƒ«
                        </button>
                    </div>
                </div>
                
                 <button id="export-layout-btn" class="w-full bg-green-500 hover:bg-green-600 text-white font-bold py-2 px-4 rounded-lg shadow-md">
                    ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆã‚’ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ
                </button>
                 <button id="import-layout-btn" class="w-full bg-purple-500 hover:bg-purple-600 text-white font-bold py-2 px-4 rounded-lg shadow-md">
                    ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆã‚’ã‚¤ãƒ³ãƒãƒ¼ãƒˆ
                </button>
                <input type="file" id="import-file-input" class="hidden" accept=".json">
                <p id="feedback-msg" class="text-center text-green-700 font-semibold opacity-0 h-4"></p>
                <button id="delete-selected-btn" class="w-full bg-yellow-500 hover:bg-yellow-600 text-white font-bold py-2 px-4 rounded-lg shadow-md">
                    é¸æŠã—ãŸã‚«ãƒ¼ãƒ‰ã‚’å‰Šé™¤
                </button>
                <button id="clear-layout-btn" class="w-full bg-red-500 hover:bg-red-600 text-white font-bold py-2 px-4 rounded-lg shadow-md">
                    å…¨ã‚«ãƒ¼ãƒ‰ã‚’å‰Šé™¤
                </button>
            </div>
        </aside>
    </div>

    <!-- ã‚«ãƒ¼ãƒ‰è¿½åŠ ãƒ¢ãƒ¼ãƒ€ãƒ« -->
    <dialog id="add-card-modal" class="p-8 bg-white rounded-xl shadow-2xl w-full max-w-xl" style="zoom: 150%;">
        <form id="add-card-form">
            <h3 class="text-2xl font-bold mb-6 text-gray-800">æ–°ã—ã„ã‚«ãƒ¼ãƒ‰ã‚’ä½œæˆ</h3>
            <fieldset class="mb-4">
                <legend class="font-semibold mb-2 text-gray-700">ã‚«ãƒ¼ãƒ‰ã®ç¨®é¡</legend>
                <div class="flex space-x-4">
                    <label class="flex items-center space-x-2"><input type="radio" name="cardType" value="playingCard" checked class="form-radio h-5 w-5 text-blue-600"><span class="text-gray-700">ãƒˆãƒ©ãƒ³ãƒ—</span></label>
                    <label class="flex items-center space-x-2"><input type="radio" name="cardType" value="colorCard" class="form-radio h-5 w-5 text-blue-600"><span class="text-gray-700">è‰²ã‚«ãƒ¼ãƒ‰</span></label>
                </div>
            </fieldset>
            <fieldset id="playing-card-options" class="space-y-4">
                <div>
                    <label for="suit" class="block font-semibold mb-1 text-gray-700">ã‚¹ãƒ¼ãƒˆ (ãƒãƒ¼ã‚¯)</label>
                    <select id="suit" name="suit" class="w-full p-2 border border-gray-300 rounded-md focus:ring-2 focus:ring-blue-500 focus:border-blue-500">
                        <option value="â™ ">ã‚¹ãƒšãƒ¼ãƒ‰ (â™ )</option><option value="â™¥">ãƒãƒ¼ãƒˆ (â™¥)</option><option value="â™¦">ãƒ€ã‚¤ãƒ¤ (â™¦)</option><option value="â™£">ã‚¯ãƒ©ãƒ– (â™£)</option>
                    </select>
                </div>
                <div>
                    <label for="card-count" class="block font-semibold mb-1 text-gray-700">ä½œè£½æšæ•°</label>
                    <input type="number" id="card-count" name="cardCount" value="1" min="1" class="w-full p-2 border border-gray-300 rounded-md focus:ring-2 focus:ring-blue-500 focus:border-blue-500">
                </div>
            </fieldset>
            <fieldset id="color-card-options" class="hidden">
                <div>
                    <label for="color" class="block font-semibold mb-1 text-gray-700">è‰²ã‚’é¸æŠ</label>
                    <input type="color" id="color" name="color" value="#ff0000" class="w-full h-12 p-1 border border-gray-300 rounded-md cursor-pointer">
                </div>
            </fieldset>

            <!-- â˜…â˜…â˜… å…±é€šè¨­å®šã‚¨ãƒªã‚¢ï¼ˆæšæ•°ãƒ»è¡Œåˆ—è¨­å®šï¼‰ â˜…â˜…â˜… -->
            <div class="mt-4 p-4 bg-gray-100 rounded-md space-y-3">
                <div>
                    <label class="block font-semibold mb-1 text-gray-700">é…ç½®ãƒ¢ãƒ¼ãƒ‰</label>
                    <div class="flex flex-col space-y-1 text-sm text-gray-700">
                        <label class="flex items-center space-x-2 cursor-pointer">
                            <input type="radio" name="layoutMode" value="single" checked class="form-radio h-4 w-4 text-blue-600">
                            <span>é€šå¸¸ï¼ˆNæšï¼‰</span>
                        </label>
                        <label class="flex items-center space-x-2 cursor-pointer">
                            <input type="radio" name="layoutMode" value="nxn" class="form-radio h-4 w-4 text-blue-600">
                            <span>N Ã— Nï¼ˆæ­£æ–¹è¡Œåˆ—ï¼‰</span>
                        </label>
                        <label class="flex items-center space-x-2 cursor-pointer">
                            <input type="radio" name="layoutMode" value="nxm" class="form-radio h-4 w-4 text-blue-600">
                            <span>N Ã— Mï¼ˆçŸ©å½¢è¡Œåˆ—ï¼‰</span>
                        </label>
                    </div>
                </div>

                <div id="layout-n-area">
                    <label class="block font-semibold mb-1 text-gray-700">Nï¼ˆè¡Œæ•° / æšæ•°ï¼‰</label>
                    <input type="number" id="card-count" name="cardCount" value="1" min="1"
                        class="w-full p-2 border border-gray-300 rounded-md focus:ring-2 focus:ring-blue-500 focus:border-blue-500">
                </div>
                <div id="layout-m-area" class="hidden">
                    <label class="block font-semibold mb-1 text-gray-700">Mï¼ˆåˆ—æ•°ï¼‰</label>
                    <input type="number" id="card-cols" name="cardCols" value="1" min="1"
                        class="w-full p-2 border border-gray-300 rounded-md focus:ring-2 focus:ring-blue-500 focus:border-blue-500">
                </div>
                <p class="text-xs text-gray-500">NÃ—N: NÂ²æš / NÃ—M: NÃ—Mæš é…ç½®</p>
            </div>

            <div class="mt-8 flex justify-end space-x-4">
                <button type="button" id="cancel-btn" class="px-6 py-2 bg-gray-200 text-gray-800 rounded-md hover:bg-gray-300">ã‚­ãƒ£ãƒ³ã‚»ãƒ«</button>
                <button type="submit" class="px-6 py-2 bg-green-500 text-white rounded-md hover:bg-green-600 font-semibold">ä½œæˆ</button>
            </div>
        </form>
    </dialog>

    <!-- ç¢ºèªãƒ¢ãƒ¼ãƒ€ãƒ« -->
    <dialog id="confirm-modal" class="p-6 bg-white rounded-lg shadow-xl w-full max-w-sm" style="zoom: 160%;">
        <h3 class="text-lg font-bold text-gray-900 mb-4">ç¢ºèª</h3>
        <p id="confirm-message" class="text-gray-700 mb-6">æœ¬å½“ã«å®Ÿè¡Œã—ã¾ã™ã‹ï¼Ÿ</p>
        <div class="flex justify-end space-x-4">
            <button id="confirm-cancel-btn" class="px-4 py-2 bg-gray-200 text-gray-800 rounded-md hover:bg-gray-300">ã„ã„ãˆ</button>
            <button id="confirm-ok-btn" class="px-4 py-2 bg-red-500 text-white rounded-md hover:bg-red-600">ã¯ã„</button>
        </div>
    </dialog>

<script>
    document.addEventListener('DOMContentLoaded', () => {
        const {icpRenderer} = require('electron');
        const board = document.getElementById('board');
        const scrollContainer = document.getElementById('scroll-container');
        const scrollWrapper = document.getElementById('scroll-wrapper');
        const canvas = document.getElementById('canvas');
        const addCardBtn = document.getElementById('add-card-btn');
        const modal = document.getElementById('add-card-modal');
        const addCardForm = document.getElementById('add-card-form');
        const cancelBtn = document.getElementById('cancel-btn');
        const cardTypeRadios = document.querySelectorAll('input[name="cardType"]');
        const playingCardOptions = document.getElementById('playing-card-options');
        const colorCardOptions = document.getElementById('color-card-options');
        const clearLayoutBtn = document.getElementById('clear-layout-btn');
        const feedbackMsg = document.getElementById('feedback-msg');
        const confirmModal = document.getElementById('confirm-modal');
        const confirmMessage = document.getElementById('confirm-message');
        const confirmOkBtn = document.getElementById('confirm-ok-btn');
        const confirmCancelBtn = document.getElementById('confirm-cancel-btn');
        const exportLayoutBtn = document.getElementById('export-layout-btn');
        const importLayoutBtn = document.getElementById('import-layout-btn');
        const importFileInput = document.getElementById('import-file-input');
        const groupSelectToggleBtn = document.getElementById('group-select-toggle-btn');
        const deleteSelectedBtn = document.getElementById('delete-selected-btn');
        const randomCutHorizonBtn = document.getElementById('random-cut-Horizon-btn');
        const randomCutVerticalBtn = document.getElementById('random-cut-Vertical-btn');
        const pileScrambleColBtn = document.getElementById('pile-scramble-col-btn');
        const pileScrambleRowBtn = document.getElementById('pile-scramble-row-btn');
        //ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆç”¨è¦ç´ 
        const templateSelect = document.getElementById('template-select');
        const applyTemplateBtn = document.getElementById('apply-template-btn');        
        const snapToGridCheck = document.getElementById('snap-to-grid-check');
        const showGridCheck = document.getElementById('show-grid-check');
        //è¡Œåˆ—ä½œæˆãƒã‚§ãƒƒã‚¯ãƒœãƒƒã‚¯ã‚¹
        const createAsMatrixCheck = document.getElementById('create-as-matrix');
        // â˜…â˜…â˜… ã‚«ã‚¦ãƒ³ã‚¿ãƒ¼è¦ç´ ã®å–å¾— â˜…â˜…â˜…
        const totalCountEl = document.getElementById('total-count');
        const selectedCountEl = document.getElementById('selected-count');
        const shuffleCountEl = document.getElementById('shuffle-count');
        const resetShuffleBtn = document.getElementById('reset-shuffle-count-btn');
        //ã‚ºãƒ¼ãƒ UI
        const zoomSlider = document.getElementById('zoom-slider');
        const zoomValue = document.getElementById('zoom-value');
        const zoomResetBtn = document.getElementById('zoom-reset-btn');
        const selectionBox = document.getElementById('selection-box');
        const updateBtn = document.getElementById('update-btn');
        const controlPanel = document.getElementById('control-panel');
        const resizer = document.getElementById('resizer');
        // ãƒ‡ãƒ¢ç”¨ã®ç°¡æ˜“å®Ÿè£…
        const protocolActionSelect = document.getElementById('protocol-action-select');
        const protocolActionCount = document.getElementById('protocol-action-count');
        const addToProtocolBtn = document.getElementById('add-to-protocol-btn');
        const protocolList = document.getElementById('protocol-list');
        const runProtocolBtn = document.getElementById('run-protocol-btn');
        const clearProtocolBtn = document.getElementById('clear-protocol-btn');
        // ãƒ©ãƒ™ãƒ«ç®¡ç†
        const labelInput = document.getElementById('label-input');
        const assignLabelBtn = document.getElementById('assign-label-btn');
        const removeLabelBtn = document.getElementById('remove-label-btn');
        const labelShuffleTarget = document.getElementById('label-shuffle-target');
        const labelPileColBtn = document.getElementById('label-pile-col-btn');
        const labelPileRowBtn = document.getElementById('label-pile-row-btn');
        const labelCutHBtn = document.getElementById('label-cut-h-btn');
        const labelCutVBtn = document.getElementById('label-cut-v-btn');
        // NÃ—M ãƒ¢ãƒ¼ãƒ€ãƒ«
        const layoutModeRadios = document.querySelectorAll('input[name="layoutMode"]');
        const layoutMArea = document.getElementById('layout-m-area');

        let protocolQueue = [];
        let zIndexCounter = 1;
        let confirmCallback = null;
        const selectedCards = new Set();
        let isGroupSelectMode = false;
        let shuffleCounter = 0; // ã‚·ãƒ£ãƒƒãƒ•ãƒ«å›æ•°
        let currentZoom = 1.0; //ã‚ºãƒ¼ãƒ çŠ¶æ…‹ã®ç®¡ç†
        // çŸ©å½¢é¸æŠç”¨ã®å¤‰æ•°
        let isSelecting = false;
        let selectionStart = { x: 0, y: 0 };
        let selectionEnd = { x: 0, y: 0 };
        //ãƒªã‚µã‚¤ã‚ºæ©Ÿèƒ½ã®èª¿æ•´ã™ã‚‹ã‹ã®åˆ¤å®š
        let isResizing = false;   
        const GRID_WIDTH = 120;
        const GRID_HEIGHT = 170;

        scrollContainer.scrollTop = (canvas.scrollHeight - scrollContainer.clientHeight) / 2;
        scrollContainer.scrollLeft = (canvas.scrollWidth - scrollContainer.clientWidth) / 2;

        if(updateBtn) {
            updateBtn.addEventListener('click', () => {
                icpRenderer.send('manual-update-check');
            });
        }
        
        // --- ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ ---
        addCardBtn.addEventListener('click', () => modal.showModal());
        cancelBtn.addEventListener('click', () => modal.close());
        modal.addEventListener('click', (e) => { if (e.target === modal) modal.close(); });

        // --- é…ç½®ãƒ¢ãƒ¼ãƒ‰åˆ‡æ›¿ ---
        layoutModeRadios.forEach(radio => {
            radio.addEventListener('change', (e) => {
                layoutMArea.classList.toggle('hidden', e.target.value !== 'nxm');
            });
        });

        // --- ãƒ©ãƒ™ãƒ«ä»˜ä¸/å‰Šé™¤ ---
        assignLabelBtn.addEventListener('click', () => {
            const label = labelInput.value.trim();
            if (!label) { showFeedback('ãƒ©ãƒ™ãƒ«åã‚’å…¥åŠ›ã—ã¦ãã ã•ã„'); return; }
            if (selectedCards.size === 0) { showFeedback('ã‚«ãƒ¼ãƒ‰ã‚’é¸æŠã—ã¦ãã ã•ã„'); return; }
            selectedCards.forEach(card => {
                const current = getCardLabels(card);
                if (!current.includes(label)) {
                    setCardLabels(card, [...current, label]);
                }
                updateCardLabelBadge(card);
            });
            updateLabelSelect();
            showFeedback(`ã€Œ${label}ã€ã‚’${selectedCards.size}æšã«ä»˜ä¸ã—ã¾ã—ãŸ`);
        });

        removeLabelBtn.addEventListener('click', () => {
            const label = labelInput.value.trim();
            if (selectedCards.size === 0) { showFeedback('ã‚«ãƒ¼ãƒ‰ã‚’é¸æŠã—ã¦ãã ã•ã„'); return; }
            selectedCards.forEach(card => {
                if (label) {
                    // å…¥åŠ›æ¬„ã«åå‰ãŒã‚ã‚Œã°ã€ãã®ãƒ©ãƒ™ãƒ«ã ã‘å‰Šé™¤
                    const current = getCardLabels(card);
                    setCardLabels(card, current.filter(l => l !== label));
                } else {
                    // å…¥åŠ›æ¬„ãŒç©ºãªã‚‰å…¨ãƒ©ãƒ™ãƒ«å‰Šé™¤
                    setCardLabels(card, []);
                }
                updateCardLabelBadge(card);
            });
            updateLabelSelect();
            showFeedback(label ? `ã€Œ${label}ã€ã‚’å‰Šé™¤ã—ã¾ã—ãŸ` : 'å…¨ãƒ©ãƒ™ãƒ«ã‚’å‰Šé™¤ã—ã¾ã—ãŸ');
        });

        // --- ãƒ©ãƒ™ãƒ«åˆ¥ã‚·ãƒ£ãƒƒãƒ•ãƒ« ---
        labelPileColBtn.addEventListener('click', () => execLabelShuffle('pileCol'));
        labelPileRowBtn.addEventListener('click', () => execLabelShuffle('pileRow'));
        labelCutHBtn.addEventListener('click', () => execLabelShuffle('cutH'));
        labelCutVBtn.addEventListener('click', () => execLabelShuffle('cutV'));

        cardTypeRadios.forEach(radio => {
            radio.addEventListener('change', (e) => {
                playingCardOptions.classList.toggle('hidden', e.target.value !== 'playingCard');
                colorCardOptions.classList.toggle('hidden', e.target.value !== 'colorCard');
            });
        });
        
        showGridCheck.addEventListener('change', (e) => {
            canvas.classList.toggle('show-grid', e.target.checked);
        });

        // â˜…â˜…â˜… ã‚·ãƒ£ãƒƒãƒ•ãƒ«å›æ•°ãƒªã‚»ãƒƒãƒˆ â˜…â˜…â˜…
        resetShuffleBtn.addEventListener('click', () => {
            shuffleCounter = 0;
            updateStatus();
        });

        // â˜…â˜…â˜… ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆé…ç½®å‡¦ç† â˜…â˜…â˜…
        applyTemplateBtn.addEventListener('click', () => {
            const templateType = templateSelect.value;
            if (templateType === 'adj_graph_g') {
                applyAdjacencyCommitmentGraphG();
            }
        });

        addCardForm.addEventListener('submit', (e) => {
            e.preventDefault();
            try {
                const formData = new FormData(addCardForm);
                const cardData = Object.fromEntries(formData.entries());
                const n = parseInt(cardData.cardCount) || 1;
                const m = parseInt(cardData.cardCols) || 1;
                const layoutMode = cardData.layoutMode || 'single'; // 'single' | 'nxn' | 'nxm'

                const placeGrid = (rows, cols) => {
                    const totalWidth = cols * GRID_WIDTH;
                    const totalHeight = rows * GRID_HEIGHT;
                    const startX = scrollContainer.scrollLeft + (scrollContainer.clientWidth / 2) - (totalWidth / 2);
                    const startY = scrollContainer.scrollTop + (scrollContainer.clientHeight / 2) - (totalHeight / 2);
                    for (let r = 0; r < rows; r++) {
                        for (let c = 0; c < cols; c++) {
                            const d = { ...cardData };
                            let left = startX + c * GRID_WIDTH;
                            let top  = startY + r * GRID_HEIGHT;
                            if (snapToGridCheck.checked) {
                                left = Math.round(left / GRID_WIDTH) * GRID_WIDTH;
                                top  = Math.round(top  / GRID_HEIGHT) * GRID_HEIGHT;
                            }
                            d.left = `${left}px`;
                            d.top  = `${top}px`;
                            d.zIndex = zIndexCounter++;
                            createCard(d);
                        }
                    }
                };

                if (layoutMode === 'nxn') {
                    placeGrid(n, n);
                } else if (layoutMode === 'nxm') {
                    placeGrid(n, m);
                } else {
                    // é€šå¸¸é…ç½®ï¼ˆé‡ã­ã¦é…ç½®ï¼‰
                    for (let i = 0; i < n; i++) {
                        const d = { ...cardData };
                        const offsetX = (i % 5) * 20 - 40;
                        const offsetY = Math.floor(i / 5) * 20 - 20;
                        let left = scrollContainer.scrollLeft + (scrollContainer.clientWidth / 2) - 56 + offsetX;
                        let top  = scrollContainer.scrollTop  + (scrollContainer.clientHeight / 2) - 80 + offsetY;
                        if (snapToGridCheck.checked) {
                            left = Math.round(left / GRID_WIDTH) * GRID_WIDTH;
                            top  = Math.round(top  / GRID_HEIGHT) * GRID_HEIGHT;
                        }
                        d.left = `${left}px`;
                        d.top  = `${top}px`;
                        d.zIndex = zIndexCounter++;
                        createCard(d);
                    }
                }

                updateStatus();
                modal.close();
                addCardForm.reset();

                // UI ãƒªã‚»ãƒƒãƒˆ
                const playingRadio = document.querySelector('input[name="cardType"][value="playingCard"]');
                if (playingRadio) playingRadio.checked = true;
                const singleRadio = document.querySelector('input[name="layoutMode"][value="single"]');
                if (singleRadio) singleRadio.checked = true;
                layoutMArea.classList.add('hidden');
                document.getElementById('card-count').value = '1';
                document.getElementById('card-cols').value = '1';
                playingCardOptions.classList.remove('hidden');
                colorCardOptions.classList.add('hidden');
            } catch (error) {
                alert("ã‚«ãƒ¼ãƒ‰ä½œæˆä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ: " + error.message);
            }
        });

        clearLayoutBtn.addEventListener('click', () => {
             showConfirm('æœ¬å½“ã«ã™ã¹ã¦ã®ã‚«ãƒ¼ãƒ‰ã‚’å‰Šé™¤ã—ã¾ã™ã‹ï¼Ÿ', () => {
                canvas.innerHTML = '';
                zIndexCounter = 1;
                clearSelection();
                updateStatus(); // â˜…â˜…â˜… æ›´æ–°
            });
        });

        deleteSelectedBtn.addEventListener('click', () => {
            if (selectedCards.size === 0) {
                showFeedback('å‰Šé™¤ã™ã‚‹ã‚«ãƒ¼ãƒ‰ãŒé¸æŠã•ã‚Œã¦ã„ã¾ã›ã‚“ã€‚');
                return;
            }

            showConfirm(`é¸æŠã—ãŸ${selectedCards.size}æšã®ã‚«ãƒ¼ãƒ‰ã‚’æœ¬å½“ã«å‰Šé™¤ã—ã¾ã™ã‹ï¼Ÿ`, () => {
                selectedCards.forEach(card => {
                    card.remove();
                });
                clearSelection();
                showFeedback('é¸æŠã—ãŸã‚«ãƒ¼ãƒ‰ã‚’å‰Šé™¤ã—ã¾ã—ãŸã€‚');
                updateStatus(); // â˜…â˜…â˜… æ›´æ–°
            });
        });

        randomCutHorizonBtn.addEventListener('click', () => {
            if (selectedCards.size < 2) {
                showFeedback('ãƒ©ãƒ³ãƒ€ãƒ ã‚«ãƒƒãƒˆã™ã‚‹ã«ã¯2æšä»¥ä¸Šé¸æŠã—ã¦ãã ã•ã„ã€‚');
                return;
            }

            const cardsArray = Array.from(selectedCards);

            // åº§æ¨™ã«åŸºã¥ã„ã¦ã‚½ãƒ¼ãƒˆï¼ˆå·¦ä¸Šã‹ã‚‰å³ä¸‹ã¸ï¼‰
            cardsArray.sort((a, b) => {
                const ay = parseInt(a.style.top || 0);
                const by = parseInt(b.style.top || 0);
                // å¤šå°‘ã®ã‚ºãƒ¬ã¯åŒã˜è¡Œã¨ã¿ãªã™
                if (Math.abs(ay - by) > GRID_HEIGHT / 2) {
                    return ay - by;
                }
                const ax = parseInt(a.style.left || 0);
                const bx = parseInt(b.style.left || 0);
                return ax - bx;
            });

            // å„ã‚«ãƒ¼ãƒ‰ã®ä½ç½®ã‚’è¨˜éŒ²
            const positions = cardsArray.map(card => ({
                left: card.style.left,
                top: card.style.top
            }));

            const n = cardsArray.length;
            
            // â˜…â˜…â˜… ä¿®æ­£: 1æšã ã‘å³ã«ç§»å‹•ï¼ˆå³ã‚·ãƒ•ãƒˆé‡1å›ºå®šï¼‰ â˜…â˜…â˜…
            const shift = 1;

            // å„ã‚«ãƒ¼ãƒ‰ã‚’æ–°ã—ã„ä½ç½®ã«ç§»å‹•ï¼ˆå³ã‚·ãƒ•ãƒˆï¼‰
            cardsArray.forEach((card, index) => {
                // å³ã‚·ãƒ•ãƒˆ: index ã®ã‚«ãƒ¼ãƒ‰ã‚’ (index + shift) % n ã®ä½ç½®ã¸
                const newPosIndex = (index + shift) % n;
                
                card.style.left = positions[newPosIndex].left;
                card.style.top = positions[newPosIndex].top;
                card.style.zIndex = zIndexCounter++;
            });

            showFeedback('1æšå³ã«ç§»å‹•ã—ã¾ã—ãŸ');
        });

        randomCutVerticalBtn.addEventListener('click', () => {
            if (selectedCards.size < 2) {
                showFeedback('ãƒ©ãƒ³ãƒ€ãƒ ã‚«ãƒƒãƒˆã™ã‚‹ã«ã¯2æšä»¥ä¸Šé¸æŠã—ã¦ãã ã•ã„ã€‚');
                return;
            }

            const cardsArray = Array.from(selectedCards);

            // ç¸¦æ–¹å‘: åŒã˜åˆ—ï¼ˆXåº§æ¨™ãŒè¿‘ã„ï¼‰ã®ã‚«ãƒ¼ãƒ‰ã‚’ã‚°ãƒ«ãƒ¼ãƒ—åŒ–
            const columns = new Map();
            cardsArray.forEach(card => {
                const x = parseInt(card.style.left || 0);
                const colKey = Math.round(x / GRID_WIDTH);
                if (!columns.has(colKey)) {
                    columns.set(colKey, []);
                }
                columns.get(colKey).push(card);
            });

            // å„åˆ—ã”ã¨ã«ç¸¦æ–¹å‘ã‚«ãƒƒãƒˆï¼ˆ1æšä¸‹ç§»å‹•ï¼‰
            columns.forEach(colCards => {
                if (colCards.length < 2) return;
                
                // Yåº§æ¨™ã§ã‚½ãƒ¼ãƒˆ
                colCards.sort((a, b) => {
                    return parseInt(a.style.top || 0) - parseInt(b.style.top || 0);
                });

                const positions = colCards.map(card => ({
                    left: card.style.left,
                    top: card.style.top
                }));

                const n = colCards.length;
                const shift = 1; // 1æšä¸‹ç§»å‹•

                colCards.forEach((card, index) => {
                    const newPosIndex = (index + shift) % n;
                    card.style.left = positions[newPosIndex].left;
                    card.style.top = positions[newPosIndex].top;
                    card.style.zIndex = zIndexCounter++;
                });
            });

            showFeedback('ç¸¦æ–¹å‘ã«1æšä¸‹ç§»å‹•ã—ã¾ã—ãŸ');
        });

        // â˜…â˜…â˜… ãƒ‘ã‚¤ãƒ«ã‚¹ã‚¯ãƒ©ãƒ³ãƒ–ãƒ«ï¼ˆåˆ—ï¼‰ã®å®Ÿè£… â˜…â˜…â˜…
        pileScrambleColBtn.addEventListener('click', () => {
            if (selectedCards.size === 0) {
                showFeedback('ã‚«ãƒ¼ãƒ‰ã‚’é¸æŠã—ã¦ãã ã•ã„ã€‚');
                return;
            }
            const cardsArray = Array.from(selectedCards);
            
            // Xåº§æ¨™ã§åˆ—ã‚’ã‚°ãƒ«ãƒ¼ãƒ—åŒ–
            const colMap = new Map();
            cardsArray.forEach(card => {
                const x = parseInt(card.style.left || 0);
                // å¤šå°‘ã®ã‚ºãƒ¬ã‚’è¨±å®¹ã—ã¦åˆ—ã‚’ã¾ã¨ã‚ã‚‹
                const colKey = Math.round(x / GRID_WIDTH);
                if (!colMap.has(colKey)) colMap.set(colKey, []);
                colMap.get(colKey).push(card);
            });

            const colKeys = Array.from(colMap.keys()).sort((a, b) => a - b);
            const n = colKeys.length;
            if (n < 2) {
                showFeedback('ã‚·ãƒ£ãƒƒãƒ•ãƒ«ã™ã‚‹åˆ—ãŒ2ã¤ä»¥ä¸Šå¿…è¦ã§ã™ã€‚');
                return;
            }

            // åˆ—ã®å…ƒã®ä»£è¡¨Xåº§æ¨™ãƒªã‚¹ãƒˆã‚’å–å¾—
            const originalXPositions = colKeys.map(key => {
                return colMap.get(key)[0].style.left;
            });

            // ãƒ©ãƒ³ãƒ€ãƒ ãªé †åˆ—ï¼ˆã‚·ãƒ£ãƒƒãƒ•ãƒ«ï¼‰ã‚’ä½œæˆ
            // ãƒ•ã‚£ãƒƒã‚·ãƒ£ãƒ¼â€“ã‚¤ã‚§ãƒ¼ãƒ„ã®ã‚·ãƒ£ãƒƒãƒ•ãƒ«
            const indices = Array.from({length: n}, (_, i) => i);
            for (let i = n - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [indices[i], indices[j]] = [indices[j], indices[i]];
            }

            // å„åˆ—ã‚’æ–°ã—ã„ä½ç½®ã¸ç§»å‹•
            colKeys.forEach((oldKey, originalIndex) => {
                const targetIndex = indices[originalIndex]; // ã‚·ãƒ£ãƒƒãƒ•ãƒ«å¾Œã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹
                const newX = originalXPositions[targetIndex]; // ãã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã®Xåº§æ¨™
                
                const cardsInCol = colMap.get(oldKey);
                cardsInCol.forEach(card => {
                    card.style.left = newX;
                    card.style.zIndex = zIndexCounter++;
                });
            });

            incrementShuffleCount();
            showFeedback(`ãƒ‘ã‚¤ãƒ«ã‚¹ã‚¯ãƒ©ãƒ³ãƒ–ãƒ«(åˆ—)ã—ã¾ã—ãŸ`);
        });

        // â˜…â˜…â˜… ãƒ‘ã‚¤ãƒ«ã‚¹ã‚¯ãƒ©ãƒ³ãƒ–ãƒ«ï¼ˆè¡Œï¼‰ã®å®Ÿè£… â˜…â˜…â˜…
        pileScrambleRowBtn.addEventListener('click', () => {
            if (selectedCards.size === 0) {
                showFeedback('ã‚«ãƒ¼ãƒ‰ã‚’é¸æŠã—ã¦ãã ã•ã„ã€‚');
                return;
            }
            const cardsArray = Array.from(selectedCards);
            
            // Yåº§æ¨™ã§è¡Œã‚’ã‚°ãƒ«ãƒ¼ãƒ—åŒ–
            const rowMap = new Map();
            cardsArray.forEach(card => {
                const y = parseInt(card.style.top || 0);
                const rowKey = Math.round(y / GRID_HEIGHT);
                if (!rowMap.has(rowKey)) rowMap.set(rowKey, []);
                rowMap.get(rowKey).push(card);
            });

            const rowKeys = Array.from(rowMap.keys()).sort((a, b) => a - b);
            const n = rowKeys.length;
            if (n < 2) {
                showFeedback('ã‚·ãƒ£ãƒƒãƒ•ãƒ«ã™ã‚‹è¡ŒãŒ2ã¤ä»¥ä¸Šå¿…è¦ã§ã™ã€‚');
                return;
            }

            // è¡Œã®å…ƒã®ä»£è¡¨Yåº§æ¨™ãƒªã‚¹ãƒˆã‚’å–å¾—
            const originalYPositions = rowKeys.map(key => {
                return rowMap.get(key)[0].style.top;
            });

            // ãƒ©ãƒ³ãƒ€ãƒ ãªé †åˆ—ã‚’ä½œæˆ
            const indices = Array.from({length: n}, (_, i) => i);
            for (let i = n - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [indices[i], indices[j]] = [indices[j], indices[i]];
            }

            // å„è¡Œã‚’æ–°ã—ã„ä½ç½®ã¸ç§»å‹•
            rowKeys.forEach((oldKey, originalIndex) => {
                const targetIndex = indices[originalIndex];
                const newY = originalYPositions[targetIndex];
                
                const cardsInRow = rowMap.get(oldKey);
                cardsInRow.forEach(card => {
                    card.style.top = newY;
                    card.style.zIndex = zIndexCounter++;
                });
            });

            incrementShuffleCount();
            showFeedback(`ãƒ‘ã‚¤ãƒ«ã‚¹ã‚¯ãƒ©ãƒ³ãƒ–ãƒ«(è¡Œ)ã—ã¾ã—ãŸ`);
        });


        confirmOkBtn.addEventListener('click', () => {
            if (confirmCallback) confirmCallback();
            confirmModal.close();
        });
        confirmCancelBtn.addEventListener('click', () => confirmModal.close());

        exportLayoutBtn.addEventListener('click', exportLayout);
        importLayoutBtn.addEventListener('click', () => importFileInput.click());
        importFileInput.addEventListener('change', importLayout);
        
        board.addEventListener('mousedown', (e) => {
            if (!isGroupSelectMode && (e.target === board || e.target === canvas)) {
                clearSelection();
            }
        });

        groupSelectToggleBtn.addEventListener('click', () => {
            isGroupSelectMode = !isGroupSelectMode;
            groupSelectToggleBtn.classList.toggle('mode-active', isGroupSelectMode);
            groupSelectToggleBtn.textContent = `ã‚°ãƒ«ãƒ¼ãƒ—é¸æŠ: ${isGroupSelectMode ? 'ON' : 'OFF'}`;
            if (!isGroupSelectMode) {
                clearSelection();
            }
        });

        //çŸ©å½¢é¸æŠã®ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ (boardã«å¯¾ã—ã¦mousedown)
        scrollContainer.addEventListener('mousedown', (e) => {
            // ã‚«ãƒ¼ãƒ‰ã‚„ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«ãŒã‚¿ãƒ¼ã‚²ãƒƒãƒˆã®å ´åˆã¯ä½•ã‚‚ã—ãªã„ï¼ˆã‚«ãƒ¼ãƒ‰ã®ãƒ‰ãƒ©ãƒƒã‚°ç­‰ã‚’å„ªå…ˆï¼‰
            // e.target ãŒ board ã¾ãŸã¯ canvas ã®å ´åˆã®ã¿çŸ©å½¢é¸æŠã‚’é–‹å§‹
            if (e.target !== scrollContainer && e.target !== canvas) return;
            if (e.button !== 0) return;

            isSelecting = true;
            
            const containerRect = scrollContainer.getBoundingClientRect();
            // ã‚ºãƒ¼ãƒ å€ç‡ã‚’è€ƒæ…®ã—ãŸåº§æ¨™è¨ˆç®—
            const startX = (e.clientX - containerRect.left + scrollContainer.scrollLeft) / currentZoom;
            const startY = (e.clientY - containerRect.top + scrollContainer.scrollTop) / currentZoom;
            
            selectionStart = { x: startX, y: startY };
            selectionEnd = { x: startX, y: startY };
            
            selectionBox.style.left = `${startX}px`;
            selectionBox.style.top = `${startY}px`;
            selectionBox.style.width = '0px';
            selectionBox.style.height = '0px';
            selectionBox.style.display = 'block';

            document.addEventListener('mousemove', onSelectionMove);
            document.addEventListener('mouseup', onSelectionUp);
        });

        // ãƒªã‚µã‚¤ã‚¶ãƒ¼
        resizer.addEventListener('mousedown', (e) => {
            e.preventDefault();
            isResizing = true;
            resizer.classList.add('resizing');
            document.body.style.cursor = 'col-resize';
            document.addEventListener('mousemove', handleResizeMove);
            document.addEventListener('mouseup', handleResizeUp);
        });

        zoomSlider.addEventListener('input', (e) => {
            setZoom(e.target.value);
        });

        zoomResetBtn.addEventListener('click', () => {
            setZoom(1.0);
        });

        addToProtocolBtn.addEventListener('click', () => {
            const action = protocolActionSelect.value;
            const count = parseInt(protocolActionCount.value) || 1;
            protocolQueue.push({ action, count });
            updateProtocolListDisplay();
        });

        clearProtocolBtn.addEventListener('click', () => {
            protocolQueue = [];
            updateProtocolListDisplay();
        });

        runProtocolBtn.addEventListener('click', runProtocol);


        // --- é–¢æ•°å®šç¾© ---

        // â˜…â˜…â˜… ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆï¼šéš£æ¥ã‚³ãƒŸãƒƒãƒˆãƒ¡ãƒ³ãƒˆ (ã‚°ãƒ©ãƒ•G) â˜…â˜…â˜…
        function applyAdjacencyCommitmentGraphG() {
            /* ã‚°ãƒ©ãƒ•Gã®éš£æ¥è¡Œåˆ— (5x5)
               é ‚ç‚¹: 1,2,3,4,5
               è¾º: (1,2), (1,5), (2,3), (3,4), (4,5)
               
               è¡Œåˆ—:
                 1 2 3 4 5
               1 H D C C D
               2 D H D C C
               3 C D H D C
               4 C C D H D
               5 D C C D H
               
               H=ãƒãƒ¼ãƒˆ(å¯¾è§’), D=ãƒ€ã‚¤ãƒ¤(1), C=ã‚¯ãƒ©ãƒ–(0)
            */
            const matrix = [
                ['â™¥', 'â™¦', 'â™£', 'â™£', 'â™¦'], // 1è¡Œç›®
                ['â™¦', 'â™¥', 'â™¦', 'â™£', 'â™£'], // 2è¡Œç›®
                ['â™£', 'â™¦', 'â™¥', 'â™¦', 'â™£'], // 3è¡Œç›®
                ['â™£', 'â™£', 'â™¦', 'â™¥', 'â™¦'], // 4è¡Œç›®
                ['â™¦', 'â™£', 'â™£', 'â™¦', 'â™¥']  // 5è¡Œç›®
            ];

            const startX = scrollContainer.scrollLeft + (scrollContainer.clientWidth / 2) - (2.5 * GRID_WIDTH);
            const startY = scrollContainer.scrollTop + (scrollContainer.clientHeight / 2) - (2.5 * GRID_HEIGHT);

            for (let r = 0; r < 5; r++) {
                for (let c = 0; c < 5; c++) {
                    const suit = matrix[r][c];
                    let left = startX + c * GRID_WIDTH;
                    let top = startY + r * GRID_HEIGHT;

                    // ã‚°ãƒªãƒƒãƒ‰ã‚¹ãƒŠãƒƒãƒ—ãŒæœ‰åŠ¹ãªã‚‰ä½ç½®ã‚’è£œæ­£
                    if (snapToGridCheck.checked) {
                        left = Math.round(left / GRID_WIDTH) * GRID_WIDTH;
                        top = Math.round(top / GRID_HEIGHT) * GRID_HEIGHT;
                    }

                    const cardData = {
                        cardType: 'playingCard',
                        suit: suit,
                        left: `${left}px`,
                        top: `${top}px`,
                        zIndex: zIndexCounter++
                    };
                    createCard(cardData);
                }
            }
            updateStatus();
            showFeedback('éš£æ¥ã‚³ãƒŸãƒƒãƒˆãƒ¡ãƒ³ãƒˆ(ã‚°ãƒ©ãƒ•G)ã‚’é…ç½®ã—ã¾ã—ãŸ');
        }
        
        // â˜…â˜…â˜… ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹æ›´æ–°é–¢æ•° â˜…â˜…â˜…
        function updateStatus() {
            const cards = canvas.querySelectorAll('.card-container');
            totalCountEl.textContent = cards.length;
            selectedCountEl.textContent = selectedCards.size;
            shuffleCountEl.textContent = shuffleCounter;
        }

        // â˜…â˜…â˜… ã‚·ãƒ£ãƒƒãƒ•ãƒ«å›æ•°ã‚¤ãƒ³ã‚¯ãƒªãƒ¡ãƒ³ãƒˆ â˜…â˜…â˜…
        function incrementShuffleCount() {
            shuffleCounter++;
            updateStatus();
        }

        function showConfirm(message, onConfirm) {
            confirmMessage.textContent = message;
            confirmCallback = onConfirm;
            confirmModal.showModal();
        }
        
        function showFeedback(message) {
            feedbackMsg.textContent = message;
            feedbackMsg.style.opacity = 1;
            setTimeout(() => { feedbackMsg.style.opacity = 0; }, 2500);
        }

        function clearSelection() {
            selectedCards.forEach(card => card.classList.remove('selected'));
            selectedCards.clear();
            updateStatus(); // â˜…â˜…â˜… æ›´æ–°
        }

        function toggleSelection(card) {
            if (selectedCards.has(card)) {
                selectedCards.delete(card);
                card.classList.remove('selected');
            } else {
                selectedCards.add(card);
                card.classList.add('selected');
            }
            updateStatus(); // â˜…â˜…â˜… æ›´æ–°
        }

        function createCard(data) {
            const cardContainer = document.createElement('div');
            cardContainer.className = 'card-container absolute w-28 h-40 cursor-grab select-none';
            cardContainer.style.left = data.left;
            cardContainer.style.top = data.top;
            cardContainer.style.zIndex = data.zIndex;
            cardContainer.dataset.cardType = data.cardType;

            const cardInner = document.createElement('div');
            cardInner.className = 'card-inner';

            const cardFront = document.createElement('div');
            cardFront.className = 'card-front bg-white shadow-lg border-2 border-gray-300';
            
            const cardBack = document.createElement('div');
            cardBack.className = 'card-back text-5xl font-bold';
            cardBack.textContent = '?';

            if (data.cardType === 'playingCard') {
                const { suit } = data;
                cardContainer.dataset.suit = suit;
                const color = (suit === 'â™¥' || suit === 'â™¦') ? 'text-red-600' : 'text-black';
                cardFront.innerHTML = `<div class="w-full h-full flex items-center justify-center text-7xl font-bold ${color}">${suit}</div>`;
            } else {
                cardContainer.dataset.color = data.color;
                cardFront.style.backgroundColor = data.color;
                cardFront.style.border = '2px solid rgba(0,0,0,0.2)';
            }
            
            if (data.flipped) cardContainer.classList.add('flipped');
            if (data.selected) toggleSelection(cardContainer); // ã“ã“ã§updateStatusãŒå‘¼ã°ã‚Œã‚‹ãŒã€ãƒ«ãƒ¼ãƒ—ä¸­ã®ãŸã‚è² è·ãŒæ°—ã«ãªã‚‹å ´åˆã¯èª¿æ•´
            
            cardInner.appendChild(cardFront);
            cardInner.appendChild(cardBack);
            cardContainer.appendChild(cardInner);

            const deleteBtn = document.createElement('div');
            deleteBtn.className = 'delete-btn';
            deleteBtn.innerHTML = '&times;';
            deleteBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                showConfirm('ã“ã®ã‚«ãƒ¼ãƒ‰ã‚’å‰Šé™¤ã—ã¾ã™ã‹ï¼Ÿ', () => {
                    cardContainer.remove();
                    if(selectedCards.has(cardContainer)) {
                        selectedCards.delete(cardContainer);
                    }
                    updateStatus(); // â˜…â˜…â˜… æ›´æ–°
                });
            });
            cardContainer.appendChild(deleteBtn);
            // ãƒ©ãƒ™ãƒ«ãƒãƒƒã‚¸
            if (data.label) {
                cardContainer.dataset.labels = data.labels;
                updateCardLabelBadge(cardContainer);
            }
            canvas.appendChild(cardContainer);

            makeDraggable(cardContainer);
            
            cardContainer.addEventListener('dblclick', () => cardContainer.classList.toggle('flipped'));
            let lastTap = 0;
            cardContainer.addEventListener('touchend', () => {
                if (cardContainer.didMove) return;
                const currentTime = new Date().getTime();
                if (currentTime - lastTap < 300) {
                    cardContainer.classList.toggle('flipped');
                }
                lastTap = currentTime;
            });
            
            cardContainer.addEventListener('contextmenu', e => e.preventDefault());
            
            if (parseInt(data.zIndex) >= zIndexCounter) {
                zIndexCounter = parseInt(data.zIndex) + 1;
            }
        }
        
        function makeDraggable(element) {
            let initialPositions = new Map();
            let dragStartPos = null;
            let didMove = false;

            function onPointerDown(e) {
                if (e.target.classList.contains('delete-btn')) return;
                const isTouchEvent = e.type === 'touchstart';
                if (!isTouchEvent) e.preventDefault();

                element.didMove = false;
                didMove = false;
                const startX = isTouchEvent ? e.touches[0].clientX : e.clientX;
                const startY = isTouchEvent ? e.touches[0].clientY : e.clientY;
                dragStartPos = { x: startX, y: startY };

                document.addEventListener(isTouchEvent ? 'touchmove' : 'mousemove', onPointerMove, { passive: false });
                document.addEventListener(isTouchEvent ? 'touchend' : 'mouseup', onPointerUp);
            }

            function onPointerMove(e) {
                if (dragStartPos === null) return;
                const isTouchEvent = e.type === 'touchmove';
                if (isTouchEvent) e.preventDefault();

                const moveX = isTouchEvent ? e.touches[0].clientX : e.clientX;
                const moveY = isTouchEvent ? e.touches[0].clientY : e.clientY;

                if (!didMove && (Math.abs(moveX - dragStartPos.x) > 5 || Math.abs(moveY - dragStartPos.y) > 5)) {
                    didMove = true;
                    element.didMove = true;
                    
                    if (!selectedCards.has(element)) {
                        if (!isGroupSelectMode) {
                            clearSelection();
                        }
                        selectedCards.add(element);
                        element.classList.add('selected');
                        updateStatus(); // â˜…â˜…â˜… æ›´æ–°
                    }

                    initialPositions.clear();
                    selectedCards.forEach(card => {
                        card.classList.add('grabbing');
                        card.style.zIndex = zIndexCounter++;
                        initialPositions.set(card, { left: card.offsetLeft, top: card.offsetTop });
                    });
                }

                if (didMove) {
                    const deltaX = moveX - dragStartPos.x;
                    const deltaY = moveY - dragStartPos.y;
                    selectedCards.forEach(card => {
                        const initialPos = initialPositions.get(card);
                        if (initialPos) {
                            let x = initialPos.left + deltaX;
                            let y = initialPos.top + deltaY;
                            
                            x = Math.max(0, Math.min(x, canvas.clientWidth - card.offsetWidth));
                            y = Math.max(0, Math.min(y, canvas.clientHeight - card.offsetHeight));
                            
                            card.style.left = `${x}px`;
                            card.style.top = `${y}px`;
                        }
                    });
                }
            }

            function onPointerUp(e) {
                if (!didMove) {
                    const isTouchEvent = e.type.startsWith('touch');
                    if (isGroupSelectMode) {
                        toggleSelection(element);
                    } else {
                        if (isTouchEvent || !e.shiftKey) {
                            clearSelection();
                        }
                        toggleSelection(element);
                    }
                } else {
                    if (snapToGridCheck.checked) {
                        selectedCards.forEach(card => {
                            let currentLeft = parseInt(card.style.left || 0);
                            let currentTop = parseInt(card.style.top || 0);

                            let snapLeft = Math.round(currentLeft / GRID_WIDTH) * GRID_WIDTH;
                            let snapTop = Math.round(currentTop / GRID_HEIGHT) * GRID_HEIGHT;

                            snapLeft = Math.max(0, Math.min(snapLeft, canvas.clientWidth - card.offsetWidth));
                            snapTop = Math.max(0, Math.min(snapTop, canvas.clientHeight - card.offsetHeight));

                            card.style.left = `${snapLeft}px`;
                            card.style.top = `${snapTop}px`;
                        });
                    }
                }

                selectedCards.forEach(card => card.classList.remove('grabbing'));
                dragStartPos = null;
                initialPositions.clear();
                
                const isTouchEvent = e.type === 'touchend';
                document.removeEventListener(isTouchEvent ? 'touchmove' : 'mousemove', onPointerMove);
                document.removeEventListener(isTouchEvent ? 'touchend' : 'mouseup', onPointerUp);
            }

            element.addEventListener('mousedown', onPointerDown);
            element.addEventListener('touchstart', onPointerDown, { passive: false });
        }

        function exportLayout() {
            const cards = Array.from(canvas.querySelectorAll('.card-container'));
            if (cards.length === 0) {
                showFeedback('ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆã™ã‚‹ã‚«ãƒ¼ãƒ‰ãŒã‚ã‚Šã¾ã›ã‚“ã€‚');
                return;
            }
            const layoutData = cards.map(card => {
                const cardData = { ...card.dataset };
                cardData.left = card.style.left;
                cardData.top = card.style.top;
                cardData.zIndex = card.style.zIndex;
                cardData.flipped = card.classList.contains('flipped');
                cardData.selected = selectedCards.has(card);
                // è¤‡æ•°ãƒ©ãƒ™ãƒ«ã¯JSONæ–‡å­—åˆ—ã®ã¾ã¾ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ
                if (card.dataset.labels) cardData.labels = card.dataset.labels;
                return cardData;
            });

            const jsonString = JSON.stringify(layoutData, null, 2);
            const blob = new Blob([jsonString], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'card_layout.json';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            showFeedback('ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆã‚’ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆã—ã¾ã—ãŸï¼');
        }

        function importLayout(event) {
            const file = event.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const layoutData = JSON.parse(e.target.result);
                    if (!Array.isArray(layoutData)) throw new Error('ç„¡åŠ¹ãªãƒ•ã‚¡ã‚¤ãƒ«å½¢å¼ã§ã™ã€‚');
                    showConfirm('ç¾åœ¨ã®ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆã‚’ã‚¯ãƒªã‚¢ã—ã¦ã‚¤ãƒ³ãƒãƒ¼ãƒˆã—ã¾ã™ã‹ï¼Ÿ', () => {
                        canvas.innerHTML = '';
                        clearSelection();
                        zIndexCounter = 1;
                        layoutData.forEach(cardData => createCard(cardData));
                        updateStatus(); // â˜…â˜…â˜… æ›´æ–°
                        showFeedback('ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆã‚’ã‚¤ãƒ³ãƒãƒ¼ãƒˆã—ã¾ã—ãŸï¼');
                    });
                } catch (error) {
                    alert('ãƒ•ã‚¡ã‚¤ãƒ«ã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸã€‚');
                } finally {
                    importFileInput.value = '';
                }
            };
            reader.readAsText(file);
        }

        function onSelectionUp(e) {
            if (!isSelecting) return;
            isSelecting = false;
            selectionBox.style.display = 'none';
            document.removeEventListener('mousemove', onSelectionMove);
            document.removeEventListener('mouseup', onSelectionUp);

            // ãƒ‰ãƒ©ãƒƒã‚°é‡ãŒå°ã•ã„å ´åˆã¯ã‚¯ãƒªãƒƒã‚¯ã¨ã¿ãªã—ã¦é¸æŠè§£é™¤
            const dist = Math.sqrt(Math.pow(selectionEnd.x - selectionStart.x, 2) + Math.pow(selectionEnd.y - selectionStart.y, 2));
            if (dist < 5) {
                // ã‚¯ãƒªãƒƒã‚¯æ™‚ã®æŒ™å‹•ï¼ˆShiftãªã—ã®å ´åˆã®ã¿å…¨è§£é™¤ã™ã‚‹ãªã©æ¡ä»¶åˆ†å²å¯èƒ½ã ãŒã€
                // å…ƒã®ä»•æ§˜ã«åˆã‚ã›ã¦ã‚¯ãƒªãƒƒã‚¯ï¼å…¨è§£é™¤ã¨ã™ã‚‹ï¼‰
                // ãŸã ã—ã€ã‚°ãƒ«ãƒ¼ãƒ—é¸æŠãƒ¢ãƒ¼ãƒ‰ONã®å ´åˆã¯è§£é™¤ã—ãªã„æ–¹ãŒã„ã„ã‹ã‚‚ã—ã‚Œãªã„ãŒã€
                // å…ƒã®ä»•æ§˜ã§ã¯ã‚¯ãƒªãƒƒã‚¯ã§è§£é™¤ã ã£ãŸã®ã§ãã‚Œã«å¾“ã†ã‹ã€Shiftã‚­ãƒ¼ã‚’è¦‹ã¦åˆ¤æ–­ã™ã‚‹ã€‚
                // ã“ã“ã§ã¯ã‚·ãƒ³ãƒ—ãƒ«ã«ã€ŒShiftã‚­ãƒ¼ãªã—ãªã‚‰å…¨è§£é™¤ã€ã¨ã™ã‚‹ã€‚
                if (!e.shiftKey) {
                    clearSelection();
                }
                return;
            }



             // çŸ©å½¢é¸æŠã®ç¢ºå®š
            const rectLeft = Math.min(selectionStart.x, selectionEnd.x);
            const rectTop = Math.min(selectionStart.y, selectionEnd.y);
            const rectRight = rectLeft + Math.abs(selectionEnd.x - selectionStart.x);
            const rectBottom = rectTop + Math.abs(selectionEnd.y - selectionStart.y);

            // Shiftã‚­ãƒ¼ãŒæŠ¼ã•ã‚Œã¦ã„ãªã„å ´åˆã¯ã€æ—¢å­˜ã®é¸æŠã‚’ã‚¯ãƒªã‚¢
            if (!e.shiftKey) {
                clearSelection();
            }

            // å…¨ã‚«ãƒ¼ãƒ‰ã«å¯¾ã—ã¦äº¤å·®åˆ¤å®š
            const cards = canvas.querySelectorAll('.card-container');
            let addedCount = 0;
            cards.forEach(card => {
                const cardLeft = parseInt(card.style.left || 0);
                const cardTop = parseInt(card.style.top || 0);
                const cardWidth = card.offsetWidth;
                const cardHeight = card.offsetHeight;
                const cardRight = cardLeft + cardWidth;
                const cardBottom = cardTop + cardHeight;

                // äº¤å·®åˆ¤å®š (AABB check)
                const isOverlapping = !(rectRight < cardLeft || 
                                      rectLeft > cardRight || 
                                      rectBottom < cardTop || 
                                      rectTop > cardBottom);

                if (isOverlapping) {
                    if (!selectedCards.has(card)) {
                        selectedCards.add(card);
                        card.classList.add('selected');
                        addedCount++;
                    }
                }
            });
            
            updateStatus();
        }

        function onSelectionMove(e) {
            if (!isSelecting) return;
            e.preventDefault();

            const containerRect = scrollContainer.getBoundingClientRect();
            // ã‚ºãƒ¼ãƒ å€ç‡ã‚’è€ƒæ…®ã—ãŸåº§æ¨™è¨ˆç®—
            const currentX = (e.clientX - containerRect.left + scrollContainer.scrollLeft) / currentZoom;
            const currentY = (e.clientY - containerRect.top + scrollContainer.scrollTop) / currentZoom;
            
            selectionEnd = { x: currentX, y: currentY };

            const left = Math.min(selectionStart.x, selectionEnd.x);
            const top = Math.min(selectionStart.y, selectionEnd.y);
            const width = Math.abs(selectionEnd.x - selectionStart.x);
            const height = Math.abs(selectionEnd.y - selectionStart.y);

            selectionBox.style.left = `${left}px`;
            selectionBox.style.top = `${top}px`;
            selectionBox.style.width = `${width}px`;
            selectionBox.style.height = `${height}px`;
        }

        function handleResizeMove(e) {
            if (!isResizing) return;
            const newWidth = document.body.clientWidth - e.clientX;
            const minWidth = 220;  // æœ€å°å¹…
            const maxWidth = Math.min(1000, document.body.clientWidth * 0.5);  // æœ€å¤§å¹…ï¼ˆç”»é¢ã®åŠåˆ†ã¾ã§ï¼‰
            
            if (newWidth >= minWidth && newWidth <= maxWidth) {
                controlPanel.style.width = `${newWidth}px`;
            }
        }

        function handleResizeUp() {
            isResizing = false;
            resizer.classList.remove('resizing');
            document.body.style.cursor = '';
            document.removeEventListener('mousemove', handleResizeMove);
            document.removeEventListener('mouseup', handleResizeUp);
        }

        // â˜…â˜…â˜… ã‚ºãƒ¼ãƒ æ©Ÿèƒ½ â˜…â˜…â˜…
        function setZoom(value) {
            const oldZoom = currentZoom;
            currentZoom = parseFloat(value);
            
            const viewportCenterX = scrollContainer.scrollLeft + scrollContainer.clientWidth / 2;
            const viewportCenterY = scrollContainer.scrollTop + scrollContainer.clientHeight / 2;
            
            const centerXInCanvas = viewportCenterX / oldZoom;
            const centerYInCanvas = viewportCenterY / oldZoom;
            
            canvas.style.transform = `scale(${currentZoom})`;
            
            const scaledWidth = canvas.offsetWidth * currentZoom;
            const scaledHeight = canvas.offsetHeight * currentZoom;
            scrollWrapper.style.width = `${scaledWidth}px`;
            scrollWrapper.style.height = `${scaledHeight}px`;
            
            scrollContainer.scrollLeft = centerXInCanvas * currentZoom - scrollContainer.clientWidth / 2;
            scrollContainer.scrollTop = centerYInCanvas * currentZoom - scrollContainer.clientHeight / 2;
            
            zoomSlider.value = currentZoom;
            zoomValue.textContent = `${Math.round(currentZoom * 100)}%`;
        }

        async function executeProtocolAction(action, targetCards) {
            switch (action) {
                case 'randomCutHorizon':
                    await execRandomCutHorizon(targetCards);
                    break;
                case 'randomCutVertical':
                    await execRandomCutVertical(targetCards);
                    break;
                case 'pileScrambleCol':
                    await execPileScrambleCol(targetCards);
                    break;
                case 'pileScrambleRow':
                    await execPileScrambleRow(targetCards);
                    break;
                case 'flip':
                    await execFlip(targetCards);
                    break;
                default:
                    console.warn('æœªçŸ¥ã®ãƒ—ãƒ­ãƒˆã‚³ãƒ«æ“ä½œ:', action);
            }
        }


        function sleep(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        function getActionLabel(action) {
            const map = {
                'randomCutHorizon': 'ãƒ©ãƒ³ãƒ€ãƒ ã‚«ãƒƒãƒˆ(æ¨ª)',
                'randomCutVertical': 'ãƒ©ãƒ³ãƒ€ãƒ ã‚«ãƒƒãƒˆ(ç¸¦)',
                'pileScrambleCol': 'ãƒ‘ã‚¤ãƒ«ã‚¹ã‚¯ãƒ©ãƒ³ãƒ–ãƒ«(åˆ—)',
                'pileScrambleRow': 'ãƒ‘ã‚¤ãƒ«ã‚¹ã‚¯ãƒ©ãƒ³ãƒ–ãƒ«(è¡Œ)',
                'flip': 'è£è¿”ã™/è¡¨ã«ã™ã‚‹'
            };
            return map[action] || action;
        }

        function updateProtocolListDisplay() {
            protocolList.innerHTML = '';
            if (protocolQueue.length === 0) {
                protocolList.innerHTML = '<p class="text-sm text-gray-400 text-center py-4 empty-msg">æ‰‹é †ãŒã‚ã‚Šã¾ã›ã‚“</p>';
                return;
            }

            protocolQueue.forEach((item, index) => {
                const div = document.createElement('div');
                div.className = 'protocol-item text-sm';
                
                const labelSpan = document.createElement('span');
                labelSpan.textContent = `${getActionLabel(item.action)} Ã— ${item.count}`;
                labelSpan.className = 'font-semibold text-gray-700';
                
                const delBtn = document.createElement('button');
                delBtn.textContent = 'Ã—';
                delBtn.className = 'text-red-500 font-bold hover:text-red-700 ml-2 px-2';
                delBtn.onclick = () => {
                    protocolQueue.splice(index, 1);
                    updateProtocolListDisplay();
                };

                div.appendChild(labelSpan);
                div.appendChild(delBtn);
                protocolList.appendChild(div);
            });
        }

        async function runProtocol() {
            if (protocolQueue.length === 0) {
                showFeedback('ãƒ—ãƒ­ãƒˆã‚³ãƒ«ãŒç©ºã§ã™');
                return;
            }

            // â˜… å®Ÿè¡Œé–‹å§‹æ™‚ã®é¸æŠã‚«ãƒ¼ãƒ‰ã‚’å›ºå®š
            const targetCards = new Set(selectedCards);

            if (targetCards.size === 0) {
                showFeedback('ã‚«ãƒ¼ãƒ‰ãŒé¸æŠã•ã‚Œã¦ã„ã¾ã›ã‚“');
                return;
            }

            runProtocolBtn.disabled = true;
            runProtocolBtn.textContent = 'å®Ÿè¡Œä¸­...';
            addToProtocolBtn.disabled = true;

            const listItems = protocolList.querySelectorAll('.protocol-item');

            try {
                for (let i = 0; i < protocolQueue.length; i++) {
                    const { action, count } = protocolQueue[i];
                    if (listItems[i]) listItems[i].classList.add('executing');

                    for (let c = 0; c < count; c++) {
                        await executeProtocolAction(action, targetCards);
                        await sleep(600);
                    }

                    if (listItems[i]) listItems[i].classList.remove('executing');
                }

                showFeedback('ãƒ—ãƒ­ãƒˆã‚³ãƒ«å®Ÿè¡Œå®Œäº†');
            } catch (e) {
                console.error(e);
                showFeedback('å®Ÿè¡Œä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ');
            } finally {
                runProtocolBtn.disabled = false;
                runProtocolBtn.textContent = 'â–¶ å®Ÿè¡Œ';
                addToProtocolBtn.disabled = false;
            }
        }

        // --- ã‚·ãƒ£ãƒƒãƒ•ãƒ«ãƒ­ã‚¸ãƒƒã‚¯ (Promiseã‚’è¿”ã™éåŒæœŸé–¢æ•°åŒ–) ---

        // ãƒ©ãƒ³ãƒ€ãƒ ã‚«ãƒƒãƒˆï¼ˆæ¨ªï¼‰
        async function execRandomCutHorizon(targetCards) {
            if (targetCards.size < 2) return;
            const cardsArray = Array.from(targetCards);
            
            cardsArray.sort((a, b) => {
                const ay = parseInt(a.style.top || 0);
                const by = parseInt(b.style.top || 0);
                if (Math.abs(ay - by) > GRID_HEIGHT / 2) return ay - by;
                return parseInt(a.style.left || 0) - parseInt(b.style.left || 0);
            });

            const positions = cardsArray.map(card => ({ left: card.style.left, top: card.style.top }));
            const n = cardsArray.length;
            const shift = Math.floor(Math.random() * (n - 1)) + 1;

            cardsArray.forEach((card, index) => {
                const newPosIndex = (index - shift + n) % n;
                card.style.left = positions[newPosIndex].left;
                card.style.top = positions[newPosIndex].top;
                card.style.zIndex = zIndexCounter++;
            });
            incrementShuffleCount();
        }

        // ãƒ©ãƒ³ãƒ€ãƒ ã‚«ãƒƒãƒˆï¼ˆç¸¦ï¼‰
        async function execRandomCutVertical(targetCards) {
            if (targetCards.size < 2) return;
            const cardsArray = Array.from(targetCards);
            const columns = new Map();
            cardsArray.forEach(card => {
                const x = parseInt(card.style.left || 0);
                const colKey = Math.round(x / GRID_WIDTH);
                if (!columns.has(colKey)) columns.set(colKey, []);
                columns.get(colKey).push(card);
            });

            columns.forEach(colCards => {
                if (colCards.length < 2) return;
                colCards.sort((a, b) => parseInt(a.style.top || 0) - parseInt(b.style.top || 0));
                const positions = colCards.map(card => ({ left: card.style.left, top: card.style.top }));
                const n = colCards.length;
                const shift = Math.floor(Math.random() * (n - 1)) + 1;
                
                colCards.forEach((card, index) => {
                    const newPosIndex = (index - shift + n) % n;
                    card.style.left = positions[newPosIndex].left;
                    card.style.top = positions[newPosIndex].top;
                    card.style.zIndex = zIndexCounter++;
                });
            });
            incrementShuffleCount();
        }

        // ãƒ‘ã‚¤ãƒ«ã‚¹ã‚¯ãƒ©ãƒ³ãƒ–ãƒ«ï¼ˆåˆ—ï¼‰
        async function execPileScrambleCol(targetCards) {
            if (targetCards.size === 0) return;
            const cardsArray = Array.from(targetCards);
            const colMap = new Map();
            cardsArray.forEach(card => {
                const x = parseInt(card.style.left || 0);
                const colKey = Math.round(x / GRID_WIDTH);
                if (!colMap.has(colKey)) colMap.set(colKey, []);
                colMap.get(colKey).push(card);
            });

            const colKeys = Array.from(colMap.keys()).sort((a, b) => a - b);
            const n = colKeys.length;
            if (n < 2) return;

            const originalXPositions = colKeys.map(key => colMap.get(key)[0].style.left);
            const indices = Array.from({length: n}, (_, i) => i);
            for (let i = n - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [indices[i], indices[j]] = [indices[j], indices[i]];
            }

            colKeys.forEach((oldKey, originalIndex) => {
                const targetIndex = indices[originalIndex];
                const newX = originalXPositions[targetIndex];
                const cardsInCol = colMap.get(oldKey);
                cardsInCol.forEach(card => {
                    card.style.left = newX;
                    card.style.zIndex = zIndexCounter++;
                });
            });
            incrementShuffleCount();
        }

        // ãƒ‘ã‚¤ãƒ«ã‚¹ã‚¯ãƒ©ãƒ³ãƒ–ãƒ«ï¼ˆè¡Œï¼‰
        async function execPileScrambleRow(targetCards) {
            if (targetCards.size === 0) return;
            const cardsArray = Array.from(targetCards);
            const rowMap = new Map();
            cardsArray.forEach(card => {
                const y = parseInt(card.style.top || 0);
                const rowKey = Math.round(y / GRID_HEIGHT);
                if (!rowMap.has(rowKey)) rowMap.set(rowKey, []);
                rowMap.get(rowKey).push(card);
            });

            const rowKeys = Array.from(rowMap.keys()).sort((a, b) => a - b);
            const n = rowKeys.length;
            if (n < 2) return;

            const originalYPositions = rowKeys.map(key => rowMap.get(key)[0].style.top);
            const indices = Array.from({length: n}, (_, i) => i);
            for (let i = n - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [indices[i], indices[j]] = [indices[j], indices[i]];
            }

            rowKeys.forEach((oldKey, originalIndex) => {
                const targetIndex = indices[originalIndex];
                const newY = originalYPositions[targetIndex];
                const cardsInRow = rowMap.get(oldKey);
                cardsInRow.forEach(card => {
                    card.style.top = newY;
                    card.style.zIndex = zIndexCounter++;
                });
            });
            incrementShuffleCount();
        }

        // è£è¿”ã™
        async function execFlip(targetCards) {
            targetCards.forEach(card => {
                card.classList.toggle('flipped');
            });
        }

        // ãƒ©ãƒ™ãƒ«ç®¡ç†
        function getCardLabels(card) {
            const raw = card.dataset.labels;
            return raw ? JSON.parse(raw) : [];
        }

        function setCardLabels(card, labels) {
            const unique = [...new Set(labels)];
            if (unique.length > 0) {
                card.dataset.labels = JSON.stringify(unique);
            } else {
                delete card.dataset.labels;
            }
        }

        function updateCardLabelBadge(card) {
            let container = card.querySelector('.card-label-badges');
            if (container) container.remove();
            const labels = getCardLabels(card);
            if (labels.length === 0) return;
            container = document.createElement('div');
            container.className = 'card-label-badges';
            labels.forEach(lbl => {
                const badge = document.createElement('div');
                badge.className = 'card-label-badge';
                // ãƒ©ãƒ™ãƒ«ã”ã¨ã«è‰²ã‚’å¤‰ãˆã‚‹
                const colors = ['#f59e0b','#3b82f6','#10b981','#ef4444','#8b5cf6','#ec4899','#06b6d4','#f97316'];
                const idx = [...lbl].reduce((s, c) => s + c.charCodeAt(0), 0) % colors.length;
                badge.style.backgroundColor = colors[idx];
                badge.textContent = lbl;
                container.appendChild(badge);
            });
            card.appendChild(container);
        }

        // ---- ãƒ©ãƒ™ãƒ«ã‚»ãƒ¬ã‚¯ãƒˆãƒœãƒƒã‚¯ã‚¹æ›´æ–° ----
        function updateLabelSelect() {
            const cards = Array.from(canvas.querySelectorAll('.card-container'));
            const labels = new Set();
            cards.forEach(c => getCardLabels(c).forEach(l => labels.add(l)));
            const current = labelShuffleTarget.value;
            labelShuffleTarget.innerHTML = '<option value="__all__">å…¨ãƒ©ãƒ™ãƒ«ï¼ˆãã‚Œãã‚Œç‹¬ç«‹ï¼‰</option>';
            [...labels].sort().forEach(l => {
                const opt = document.createElement('option');
                opt.value = l;
                opt.textContent = `ãƒ©ãƒ™ãƒ«ã€Œ${l}ã€ã®ã¿`;
                labelShuffleTarget.appendChild(opt);
            });
            if ([...labels, '__all__'].includes(current)) labelShuffleTarget.value = current;
        }

        // ---- ãƒ©ãƒ™ãƒ«åˆ¥ã‚·ãƒ£ãƒƒãƒ•ãƒ«å®Ÿè¡Œ ----
        function execLabelShuffle(type) {
            const allCards = Array.from(canvas.querySelectorAll('.card-container'));
            const target = labelShuffleTarget.value;

            // ãƒ©ãƒ™ãƒ«ã”ã¨ã«ã‚°ãƒ«ãƒ¼ãƒ—åŒ–ï¼ˆ1æšãŒè¤‡æ•°ãƒ©ãƒ™ãƒ«ã‚’æŒã¤å ´åˆã€å„ãƒ©ãƒ™ãƒ«ã‚°ãƒ«ãƒ¼ãƒ—ã«å‚åŠ ï¼‰
            const groups = new Map();
            allCards.forEach(card => {
                getCardLabels(card).forEach(lbl => {
                    if (target !== '__all__' && lbl !== target) return;
                    if (!groups.has(lbl)) groups.set(lbl, []);
                    groups.get(lbl).push(card);
                });
            });

            if (groups.size === 0) { showFeedback('å¯¾è±¡ãƒ©ãƒ™ãƒ«ä»˜ãã‚«ãƒ¼ãƒ‰ãŒã‚ã‚Šã¾ã›ã‚“'); return; }

            groups.forEach((groupCards) => {
                const cardSet = new Set(groupCards);
                switch (type) {
                    case 'pileCol': execPileScrambleCol(cardSet); break;
                    case 'pileRow': execPileScrambleRow(cardSet); break;
                    case 'cutH':   execRandomCutHorizon(cardSet); break;
                    case 'cutV':   execRandomCutVertical(cardSet); break;
                }
            });

            const typeLabel = { pileCol:'åˆ—ã‚¹ã‚¯ãƒ©ãƒ³ãƒ–ãƒ«', pileRow:'è¡Œã‚¹ã‚¯ãƒ©ãƒ³ãƒ–ãƒ«', cutH:'æ¨ªã‚«ãƒƒãƒˆ', cutV:'ç¸¦ã‚«ãƒƒãƒˆ' }[type];
            showFeedback(`ãƒ©ãƒ™ãƒ«åˆ¥ ${typeLabel} å®Œäº†`);
        }

        // DOMContentLoadedå†…ã®åˆæœŸåŒ–éƒ¨åˆ†ã«è¿½åŠ 
        function updateScrollContainerSize() {
            const scaledWidth = canvas.offsetWidth * currentZoom;
            const scaledHeight = canvas.offsetHeight * currentZoom;
            scrollWrapper.style.width = `${scaledWidth}px`;
            scrollWrapper.style.height = `${scaledHeight}px`;
        }
        
        // åˆæœŸçŠ¶æ…‹æ›´æ–°
        updateStatus();
        updateScrollContainerSize();
    });
</script>

</body>
</html>